---
title: "FRANCE CAC 40 index"
author: 'Enjo, Filippo, Stephane '
date: "6/9/2021"
output:
  pdf_document: default
  html_document: default
---

\listoftables

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

```{r data}
require(readxl)
require(xts)
require(PerformanceAnalytics)
require(kableExtra)
require(fitdistrplus)
require(fGarch)
require(tree)  # do we need this?
require(sgt)
require(devtools)
require(zoo)
require(stringr)
require(rugarch)
require(plyr)
require(dplyr)
require(GAS)

suppressMessages(install_bitbucket("alexiosg/racd"))
options(knitr.kable.NA = "")
remotes::install_github("R-Finance/xtsExtra")
data <- suppressWarnings(read_excel("data/Price_Return.xlsx", 
                                    sheet = "Return", col_types = c("date", 
                                                                    "numeric", "numeric", "numeric", 
                                                                    "numeric"))) #warnings are NA's
colnames(data) <- c("Date", colnames(data)[-1])
indices <- as.xts(data[,-1], order.by = data$Date)
Estoxx <- indices[,2] #CAC40
Estoxx <- na.omit(Estoxx)

R <- diff(Estoxx, log = TRUE, na.pad = FALSE)*100
R <- na.omit(R) 
```

```{r prepstats, echo=F}
## RETURNS
#selecting relevant statistics only from table.Stats
Statistics <-  table.Stats(R)
Stats.names <- rownames(Statistics)[-c(1,2,4,7,8,10:13)]
Statistics <- Statistics[-c(1,2,4,7,8,10:13),] 
names(Statistics) <- Stats.names

# Skewness test
skewtest <- normtest::skewness.norm.test(coredata(R)) #as you can see the skewness is the same as the table.Stats method
Skewness <- round(skewtest$statistic,4)
names(Skewness) <- "Skewness"
skewness.pvalue <- skewtest$p.value
kurttest <- normtest::kurtosis.norm.test(coredata(R)) #this is normal kurtosis (not excess)
Excess_kurtosis <- round(kurttest$statistic,4) - 3 
names(Excess_kurtosis) <- "Excess Kurtosis"
kurtosis.pvalue <- kurttest$p.value

# Jb test
robustjb_R <- DescTools::JarqueBeraTest(coredata(R)) #robust?
jb_R <- normtest::jb.norm.test(R)

jb_R <- paste0(round(jb_R$statistic,4),"***")
names(jb_R) <- "Jarque-Bera"

# PART 1
Statistics <-  c(Statistics[1:5], Skewness, paste0("(",skewness.pvalue,"***)"), Excess_kurtosis, paste0("(",kurtosis.pvalue,"***)"),jb_R)

## STANDARDIZED RESIDUALS
garchspec.R <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "sGARCH", variance.targeting = F), 
                     distribution.model = "norm")
# Estimate the model
garchfit.R <- ugarchfit(data = R, spec = garchspec.R)

# Compute stdret using residuals()
stdret.R <- rugarch::residuals(garchfit.R, standardize = TRUE)

Statistics.S <-  table.Stats(stdret.R)
Stats.names.S <- rownames(Statistics.S)[-c(1,2,4,7,8,10:13)]
Statistics.S <- Statistics.S[-c(1,2,4,7,8,10:13),] #selecting relevant columns only
Statistics.S <- Statistics.S[,1]
names(Statistics.S) <- Stats.names.S

# Skewness test
skewtest <- normtest::skewness.norm.test(coredata(stdret.R)) #as you can see the skewness is the same as the table.Stats method
Skewness <- round(skewtest$statistic,4)
names(Skewness) <- "Skewness"
skewness.pvalue <- skewtest$p.value
kurttest <- normtest::kurtosis.norm.test(coredata(stdret.R)) #this is normal kurtosis (not excess)
Excess_kurtosis <- round(kurttest$statistic,4) - 3
names(Excess_kurtosis) <- "Excess Kurtosis"
kurtosis.pvalue <- kurttest$p.value

# Jb test
robustjb_R <- DescTools::JarqueBeraTest(coredata(stdret.R)) #robust?
jb_R <- normtest::jb.norm.test(stdret.R)

jb_R <- paste0(round(jb_R$statistic,4),"***")
names(jb_R) <- "Jarque-Bera"

Statistics.S <- c(Statistics.S[1:5], Skewness, paste0("(",skewness.pvalue,"***)"), Excess_kurtosis, paste0("(",kurtosis.pvalue,"***)"),jb_R)

# for table 1
table1 <- data.frame(Statistics = names(Statistics.S)[c(3,2,4,1,5:10)], `Euro Stoxx 50` = Statistics[c(3,2,4,1,5:10)], `Standardized Residuals`= Statistics.S[c(3,2,4,1,5:10)])
colnames(table1) <- gsub(pattern = '\\.', replacement=' ',colnames(table1))

fn1 <- sprintf(paste0('This table shows the descriptive statistics of the daily percentage returns of %s over the period %s to %s (', nrow(R),' observations). Including arithmetic mean, median, maximum, minimum, standard deviation. The skewness, excess kurtosis with p-value and signicance and the Jarque-Bera test with significance.'),str_to_title(gsub(pattern = '\\.', replacement=' ',colnames(R))),gsub(" UTC", "",min(index(R))),gsub(" UTC", "",max(index(R))))
fn2 <- paste("The standardized residual is derived from a maximum likelihood estimation (simple GARCH model) as follows: ", "$ R_t=\\\\alpha_0+\\\\alpha_1 R_{t-1}+z_t \\\\sigma_t \\\\\\\\ \\\\sigma_t^2=\\\\beta_0+\\\\beta_1 \\\\sigma_{t-1}^2 z_{t-1}^2+\\\\beta_2 \\\\sigma_{t-1}^2, \\\\\\\\$",  "Where $z$ is the standard residual (assumed to have a normal distribution).")
fn3 <- '*, **, *** represent significance levels at the 5%, 1% and <1%.'
```

```{r stats, echo=F, results='asis', fig.pos="h!"}
table1 %>% kbl(caption = "Summary statistics of the returns",
               "latex",
               label = 'dsTable',
               booktabs = T,
               position = "h!",
               digits = 3 )%>%
  kable_classic(full_width = F)%>% 
  footnote(number_title = "Notes",
           number=c(fn1,fn2,fn3),
           threeparttable = T,
           footnote_as_chunk = F, 
           escape=F)
```

\newpage

```{r}
load("CAC40.RData")
source("Custom_Functions.R")
```


```{r garch, eval = F}
# GARCHCODE ===========
distributions <- c("norm", "std", "sstd", "ged", "sged")
Models.garch <- c("sGARCH","eGARCH","fGARCH.AVGARCH","fGARCH.NAGARCH", "gjrGARCH", "fGARCH.TGARCH", "iGARCH", "EWMA")
Models.garch.clean <-  toupper(gsub("fGARCH.", "", Models.garch)) # we use this for tables

for(i in 1:length(Models.garch)){
  assign(paste0("garchspec.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
  assign(paste0("garchfit.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
  assign(paste0("stdret.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
}


#.sGARCH
for(i in 1:length(distributions)){
  # Specify a GARCH model with constant mean
  garchspec.sGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                                      variance.model = list(model = "sGARCH", garchOrder = c(1,1), variance.targeting = F),
                                      distribution.model = distributions[i])
  # Estimate the model
  garchfit.sGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.sGARCH[[i]])
}
#.eGARCH
for(i in 1:length(distributions)){
  # Specify a GARCH model with constant mean
  garchspec.eGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                                      variance.model = list(model = "eGARCH", variance.targeting = F),
                                      distribution.model = distributions[i])
  # Estimate the model
  garchfit.eGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.eGARCH[[i]])
  # Compute stdret using residuals()
}

#.fGARCH.NAGARCH
for(i in 1:length(distributions)){
  # Specify a GARCH model with constant mean
  garchspec.fGARCH.NAGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                                              variance.model = list(model = "fGARCH", submodel = "NAGARCH", variance.targeting = F),
                                              distribution.model = distributions[i])
  # Estimate the model
  garchfit.fGARCH.NAGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.fGARCH.NAGARCH[[i]])
  # Compute stdret using residuals()
}

#.fGARCH.AVGARCH
for(i in 1:length(distributions)){
  # Specify a GARCH model with constant mean
  garchspec.fGARCH.AVGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                                              variance.model = list(model = "fGARCH", submodel = "AVGARCH", variance.targeting = F),
                                              distribution.model = distributions[i])
  # Estimate the model
  garchfit.fGARCH.AVGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.fGARCH.AVGARCH[[i]])
  # Compute stdret using residuals()
}

#.gjrGARCH
for(i in 1:length(distributions)){
  # Specify a GARCH model with constant mean
  garchspec.gjrGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                                        variance.model = list(model = "gjrGARCH", variance.targeting = F),
                                        distribution.model = distributions[i])
  # Estimate the model
  garchfit.gjrGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.gjrGARCH[[i]])
  # Compute stdret using residuals()
}

#fGARCH.TGARCH
for(i in 1:length(distributions)){
  # Specify a GARCH model with constant mean
  garchspec.fGARCH.TGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                                             variance.model = list(model = "fGARCH", submodel = "TGARCH", variance.targeting = F),
                                             distribution.model = distributions[i])
  # Estimate the model
  garchfit.fGARCH.TGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.fGARCH.TGARCH[[i]])
  # Compute stdret using residuals()
}

#.iGARCH
for(i in 1:length(distributions)){
  # Specify a GARCH model with constant mean
  garchspec.iGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                                      variance.model = list(model = "iGARCH", variance.targeting = F),
                                      distribution.model = distributions[i])
  # Estimate the model
  garchfit.iGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.iGARCH[[i]])
  # Compute stdret using residuals()
}

#.EWMA
for(i in 1:length(distributions)){
  # Specify a GARCH model with constant mean
  garchspec.EWMA[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                                    variance.model = list(model = "iGARCH", variance.targeting = F),
                                    distribution.model = distributions[i], fixed.pars = list(omega=0))
  # Estimate the model
  garchfit.EWMA[[i]] <- ugarchfit(data = R, spec = garchspec.EWMA[[i]])
  # Compute stdret using residuals()
}
```

\clearpage

```{r aictableprep, eval=F}
aic_sGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_sGARCH[i] = infocriteria(garchfit.sGARCH[[i]])[1]
}

aic_iGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_iGARCH[i] = infocriteria(garchfit.iGARCH[[i]])[1]
}

aic_EWMA <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_EWMA[i] = infocriteria(garchfit.EWMA[[i]])[1]
}

aic_eGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_eGARCH[i] = infocriteria(garchfit.eGARCH[[i]])[1]
}

aic_gjrGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_gjrGARCH[i] = infocriteria(garchfit.gjrGARCH[[i]])[1]
}

aic_naGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_naGARCH[i] = infocriteria(garchfit.fGARCH.NAGARCH[[i]])[1]
}

aic_tGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_tGARCH[i] = infocriteria(garchfit.fGARCH.TGARCH[[i]])[1]
}

aic_avgarch <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_avgarch[i] = infocriteria(garchfit.fGARCH.AVGARCH[[i]])[1]
}

aics <- matrix(ncol=length(Models.garch), nrow = length(distributions))
rownames(aics) <- c("N", "T", "ST", "GED", "SGED")
colnames(aics) <- Models.garch.clean[c(1,7,8,2,5,4,6,3)]
aics[,1] <- aic_sGARCH
aics[,2] <- aic_iGARCH
aics[,3] <- aic_EWMA
aics[,4] <- aic_eGARCH
aics[,5] <- aic_gjrGARCH
aics[,6] <- aic_naGARCH
aics[,7] <- aic_tGARCH
aics[,8] <- aic_avgarch

tableAIC <- as.data.frame(round(aics,4))
tableAIC <- rbind(tableAIC[5,], tableAIC[4,], tableAIC[3,], tableAIC[2,],tableAIC[1,])



# for ourselves: quick conditional formatting
#require(condformat)
# cf <-  condformat(tableAIC) %>%
#   rule_fill_discrete(SGARCH,expression =SGARCH==min(SGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(IGARCH,expression =IGARCH==min(IGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(EWMA,expression =EWMA==min(EWMA), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(EGARCH,expression =EGARCH==min(EGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(GJRGARCH,expression =GJRGARCH==min(GJRGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(NAGARCH,expression =NAGARCH==min(NAGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen"))  %>%
#   rule_fill_discrete(TGARCH,expression =TGARCH==min(TGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(AVGARCH,expression =AVGARCH==min(AVGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen"))
```

```{r aictablelatex, echo=F, results='asis'}
aics %>% kbl(caption = "Model selection according to AIC",
      label = 'aicTable',format="latex",
      booktabs = T,
      position = "h!",
      digits = 3 )%>%
  kable_classic(full_width = F)%>%
  footnote(general_title= "Notes",general="This table shows the AIC value for the respective model. With on the rows the distributions. ",threeparttable = T,footnote_as_chunk = F, escape=F) %>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

```{r table3, results='asis'}
# TABLE GARCHCODE ----
Table.3.iGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.iGARCH)
Table.3.eGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.eGARCH)
Table.3.gjrGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.gjrGARCH)
Table.3.sGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.sGARCH)
Table.3.EWMA <- Table.GARCH.function(GARCHfit.object = garchfit.EWMA)
Table.3.fGARCH.AVGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.fGARCH.AVGARCH)
Table.3.fGARCH.NAGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.fGARCH.NAGARCH)
Table.3.fGARCH.TGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.fGARCH.TGARCH)
Table.3 <- vector(mode = "list", length = length(distributions))
names(Table.3) <- c("Norm", "T", "ST", "GED", "SGED")
for(i in 1:length(distributions)){
  Table.3[[i]] <- suppressMessages(Table.3.function(distribution = distributions[i]))
}
Table.3$ST[15,-1] <- as.numeric(Table.3$ST[15,-1])/2
patterns <- str_count(Table.3$ST[16,-1], "\\*")
numbers <- tidyr::extract_numeric(Table.3$ST[16,-1])/2
for (i in 1:length(patterns)){
  Table.3$ST[16,i+1] <- paste0("(", numbers[i], ")", paste(rep("*",patterns[i]),collapse = ""))
} 

fn1.3 <- sprintf(paste0('This table shows the maximum likelihood estimates of various ST-GARCHmodels.
                        The daily returns used on the ',toupper(gsub(pattern = '\\.', replacement=' ',colnames(R)))," cover the period from ",gsub(" UTC", "",format(min(index(R)), '%d %B, %Y'))," to ",gsub(" UTC", "",format(max(index(R)),'%d %B, %Y')), " (", nrow(R)," observations)."))
fn2.3 <- sprintf("The mean process is modeled as follows: $R_t= \\\\alpha_0+ \\\\alpha_1 \\\\times R_{t-1}+ \\\\varepsilon_t$ Where, in the %s GARCH models estimated, $\\\\gamma$ is the asymmetry in volatility, $\\\\xi, \\\\kappa$ and $\\\\eta$ are constant and robust standard errors based on the method of White (1982)) are displayed in parenthesis. $LLH$ is the maximized log likelihood value.", ncol(Table.3$ST)-1)

kable(Table.3$ST[-c(13,14),], 
    col.names = toupper(colnames(Table.3$ST)),
    caption = "Maximum likelihood estimates of the ST-GARCH models with constant skewness and kurtosis parameters",
    format="latex",
    label = 'Table3',
    booktabs = T, row.names = F, escape = F )%>%
  kable_classic(full_width = F)%>%
  footnote(general = c(fn1.3,fn2.3),
           threeparttable = T,
           footnote_as_chunk = F, 
           escape=F,
           general_title = "Notes:")%>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

\clearpage

```{r table3b, results='asis'}
fn1.3b <- sprintf(paste0('This table shows the maximum likelihood estimates of various SGED-    \\\\\\\\ GARCH models.
                        The daily returns used on the ',toupper(gsub(pattern = '\\.', replacement=' ',colnames(R)))," cover   \\\\\\\\ the period
                        from ",gsub(" UTC", "",format(min(index(R)), '%d %B, %Y'))," to ",gsub(" UTC", "",format(max(index(R)),'%d %B, %Y')), " (", nrow(R)," observations)."))
fn2.3 <- sprintf("The mean process is modeled as follows: $R_t= \\\\alpha_0+ \\\\alpha_1 \\\\times R_{t-1}+ \\\\varepsilon_t$ Where, in the %s GARCH models estimated, $\\\\gamma$ is the asymmetry in volatility, $\\\\xi, \\\\kappa$ and $\\\\eta$ are constant and robust standard errors based on the method of White (1982)) are displayed in parenthesis. $LLH$ is the maximized log likelihood value.", ncol(Table.3$ST)-1)


kable(Table.3$SGED[-c(13,14),], 
      col.names = toupper(colnames(Table.3$SGED)),
      caption = "Maximum likelihood estimates of the SGED-GARCH models with constant skewness and kurtosis parameters",
      format = "latex",
    label = 'Table3b',
    booktabs = T, row.names = F, escape = F )%>%
  kable_classic(full_width = F)%>%
  footnote(general = fn1.3b,
           threeparttable = T,
           footnote_as_chunk = F, 
           escape=F, 
           general_title = "Notes:")%>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

\clearpage

```{r garchroll, eval = FALSE}
# VaR garchroll forecasting and backtesting----
# x = garchspec.eGARCH[[i]]
roll <- function(x) { 
  cl = makePSOCKcluster(10)
  result = ugarchroll(x,data = R,n.ahead = 1,n.start = 2500,forecast.length=1,refit.every = 22,solver = "hybrid",refit.window="moving",calculate.VaR=TRUE,VaR.alpha=0.01, cluster = cl, keep.coef=TRUE)
  stopCluster(cl)
  return(result)
}
# Enjo Timing = first hash
```

```{r garchrollegarch, eval = FALSE}
egarch.normback <- roll(garchspec.eGARCH[[1]]) #37.66 sec
egarch.stdback <- roll(garchspec.eGARCH[[2]])  #1,3min 
egarch.sstdback <- roll(garchspec.eGARCH[[3]]) #1.5min
egarch.gedback <- roll(garchspec.eGARCH[[4]])  #1.1min
egarch.sgedback <- roll(garchspec.eGARCH[[5]]) #2min 
```

```{r garchrollgjrgarch, eval = FALSE}
gjrgarch.normback <- roll(garchspec.gjrGARCH[[1]]) #14.23 sec
gjrgarch.stdback <- roll(garchspec.gjrGARCH[[2]])  #19.36 sec
gjrgarch.sstdback <- roll(garchspec.gjrGARCH[[3]]) #24.75 sec
gjrgarch.gedback <- roll(garchspec.gjrGARCH[[4]])  #21.13 sec
gjrgarch.sgedback <- roll(garchspec.gjrGARCH[[5]]) #30.24 sec
```

```{r garchrollnagarch, eval = FALSE}
nagarch.normback <- roll(garchspec.fGARCH.NAGARCH[[1]]) #14.88 sec
nagarch.stdback <- roll(garchspec.fGARCH.NAGARCH[[2]])  #20.31 sec
nagarch.sstdback <- roll(garchspec.fGARCH.NAGARCH[[3]]) #27.25 sec
nagarch.gedback <- roll(garchspec.fGARCH.NAGARCH[[4]])  #22.39 sec
nagarch.sgedback <- roll(garchspec.fGARCH.NAGARCH[[5]]) #34.98 sec
```

```{r garchrolltgarch, eval = FALSE}
tgarch.normback <- roll(garchspec.fGARCH.TGARCH[[1]]) #15.48 sec
tgarch.stdback <- roll(garchspec.fGARCH.TGARCH[[2]])  #19.32 sec
tgarch.sstdback <- roll(garchspec.fGARCH.TGARCH[[3]]) #26.27 sec
tgarch.gedback <- roll(garchspec.fGARCH.TGARCH[[4]])  #20.26 sec
tgarch.sgedback <- roll(garchspec.fGARCH.TGARCH[[5]]) #29.29 sec
```

```{r garchrollavgarch, eval = FALSE}
avgarch.normback <- roll(garchspec.fGARCH.AVGARCH[[1]]) #20.65 sec
avgarch.stdback <- roll(garchspec.fGARCH.AVGARCH[[2]])  #35.63 sec
avgarch.sstdback <- roll(garchspec.fGARCH.AVGARCH[[3]]) #52.54 sec
avgarch.gedback <- roll(garchspec.fGARCH.AVGARCH[[4]])  #42.59 sec
avgarch.sgedback <- roll(garchspec.fGARCH.AVGARCH[[5]]) #1.03 min
# q1 = q5 = px = matrix(NA, ncol = 1, nrow = 6453)
# q1[, 1] = as.numeric(apply(egarch.normback@forecast$density, 1, function(x) qdist("norm", 0.01, mu = x['Mu'], sigma = x['Sigma'], skew = x['Skew'], shape = x['Shape'])))
# q5[, 1] = as.numeric(apply(egarch.normback@forecast$density, 1, function(x) qdist("norm", 0.05, mu = x['Mu'], sigma = x['Sigma'], skew = x['Skew'], shape = x['Shape'])))
# VaR1cc1 = apply(q1, 2, function(x) VaRTest(0.01, actual = egarch.normback@forecast$VaR[, 'realized'], VaR = x))
# VaR5cc1 = apply(q5, 2, function(x) VaRTest(0.05, actual = egarch.normback@forecast$VaR[, 'realized'], VaR = x))
```

```{r gaspackagetests, include=F, eval=F}
getVaR <- function(x) {
  VaRresult <- as.data.frame(x,which="VaR")$`alpha(1%)`
}
VaR.norm.egarch <- getVaR(egarch.normback)
VaR.std.egarch <- getVaR(egarch.stdback)
VaR.ged.egarch <- getVaR(egarch.gedback)
VaR.sstd.egarch <- getVaR(egarch.sstdback)
VaR.sged.egarch <- getVaR(egarch.sgedback)

VaR.norm.gjrgarch <- getVaR(gjrgarch.normback)
VaR.std.gjrgarch <- getVaR(gjrgarch.stdback)
VaR.ged.gjrgarch <- getVaR(gjrgarch.gedback)
VaR.sstd.gjrgarch <- getVaR(gjrgarch.sstdback)
VaR.sged.gjrgarch <- getVaR(gjrgarch.sgedback)

VaR.norm.tgarch <- getVaR(tgarch.normback)
VaR.std.tgarch <- getVaR(tgarch.stdback)
VaR.ged.tgarch <- getVaR(tgarch.gedback)
VaR.sstd.tgarch <- getVaR(tgarch.sstdback)
VaR.sged.tgarch <- getVaR(tgarch.sgedback)

VaR.norm.nagarch <- getVaR(nagarch.normback)
VaR.std.nagarch <- getVaR(nagarch.stdback)
VaR.ged.nagarch <- getVaR(nagarch.gedback)
VaR.sstd.nagarch <- getVaR(nagarch.sstdback)
VaR.sged.nagarch <- getVaR(nagarch.sgedback)

VaR.norm.avgarch <- getVaR(avgarch.normback)
VaR.std.avgarch <- getVaR(avgarch.stdback)
VaR.ged.avgarch <- getVaR(avgarch.gedback)
VaR.sstd.avgarch <- getVaR(avgarch.sstdback)
VaR.sged.avgarch <- getVaR(avgarch.sgedback)

gettests <- function(x) { 
  # modify this according to your needs
  uc <- BacktestVaR(R[2501:nrow(R)],x,0.01, 5)$LRuc
  cc <- BacktestVaR(R[2501:nrow(R)],x,0.01, 5)$LRcc
  ae <- BacktestVaR(R[2501:nrow(R)],x,0.01, 5)$AE
  dq <- BacktestVaR(R[2501:nrow(R)],x,0.01, 5)$DQ
  return(list = list(ae = ae, uc = uc, cc = cc, dq = dq))
}
```

```{r ES_Test, eval=F}
ESTesting <- function(garch.back, var, dist){
  
  roll <- as.data.frame(garch.back, which = "density",)
  f <- function(x, skew, shape) qdist(dist, p = x, mu = 0, sigma = 1, skew = skew, shape = shape)
  #VaR in same fashion as ES below, and gives the same VaR as previously found so it is redundant.
  # VaR <- roll[,'Mu'] + qdist(dist, 0.01, mu = 0, sigma =1, skew = roll[,'Skew'], shape = roll[,'Shape']) * roll[,'Sigma']
  ES <- roll['Mu'] + roll['Sigma']*apply(roll, 1, function(x)
    integrate(f,0,0.01, skew = x['Skew'], shape = x['Shape'])$value/0.01)
  names(ES) <- "ES"
  ESTest_object <- ESTest(0.01, R[-c(1:2500),], ES[,1], var, conf.level = 0.99, boot = T)
  # length(R)
  # nrow(ES)
  # length(VaR.sstd.egarch)
  AE_ES <- as.numeric(ESTest_object[2])/as.numeric(ESTest_object[1])
  AE_ES.p <- ESTest_object[4] #bootstrapped p-value
  return(list(ES,AE_ES,AE_ES.p))
}

#ES for egarch

e_sged_ES <- ESTesting(egarch.sgedback, VaR.sged.egarch, "sged")
e_sged_AE_ES <- e_sged_ES[2]
e_sged_AE_p <- e_sged_ES[[3]] 

e_ged_ES <- ESTesting(egarch.gedback, VaR.ged.egarch, "ged")
e_ged_AE_ES <- e_ged_ES[2]
e_ged_AE_p <- e_ged_ES[[3]] 

e_sstd_ES <- ESTesting(egarch.sstdback, VaR.sstd.egarch, "sstd")
e_sstd_AE_ES <- e_sstd_ES[2]
e_sstd_AE_p <- e_sstd_ES[[3]] 

e_std_ES <- ESTesting(egarch.sstdback, VaR.std.egarch, "std")
e_std_AE_ES <- e_std_ES[2]
e_std_AE_p <- e_std_ES[[3]] 

e_norm_ES <- ESTesting(egarch.normback, VaR.norm.egarch, "norm")
e_norm_AE_ES <- e_norm_ES[2]
e_norm_AE_p <- e_norm_ES[[3]]

#ES for gjrgarch

gjr_sged_ES <- ESTesting(gjrgarch.sgedback, VaR.sged.gjrgarch,"sged")
gjr_sged_AE_ES <- gjr_sged_ES[2]
gjr_sged_AE_p <- gjr_sged_ES[[3]] 

gjr_ged_ES <- ESTesting(gjrgarch.gedback, VaR.ged.gjrgarch,"ged")
gjr_ged_AE_ES <- gjr_ged_ES[2]
gjr_ged_AE_p <- gjr_ged_ES[[3]] 

gjr_sstd_ES <- ESTesting(gjrgarch.sstdback, VaR.sstd.gjrgarch,"sstd")
gjr_sstd_AE_ES <- gjr_sstd_ES[2]
gjr_sstd_AE_p <- gjr_sstd_ES[[3]] 

gjr_std_ES <- ESTesting(gjrgarch.sstdback,VaR.std.gjrgarch, "std")
gjr_std_AE_ES <- gjr_std_ES[2]
gjr_std_AE_p <- gjr_std_ES[[3]] 

gjr_norm_ES <- ESTesting(gjrgarch.normback, VaR.norm.gjrgarch,"norm")
gjr_norm_AE_ES <- gjr_norm_ES[2]
gjr_norm_AE_p <- gjr_norm_ES[[3]]

#ES for tgarch

t_sged_ES <- ESTesting(tgarch.sgedback, VaR.sged.tgarch,"sged")
t_sged_AE_ES <- t_sged_ES[2]
t_sged_AE_p <- t_sged_ES[[3]] 

t_ged_ES <- ESTesting(tgarch.gedback, VaR.ged.tgarch,"ged")
t_ged_AE_ES <- t_ged_ES[2]
t_ged_AE_p <- t_ged_ES[[3]] 

t_sstd_ES <- ESTesting(tgarch.sstdback, VaR.sstd.tgarch,"sstd")
t_sstd_AE_ES <- t_sstd_ES[2]
t_sstd_AE_p <- t_sstd_ES[[3]] 

t_std_ES <- ESTesting(tgarch.sstdback, VaR.std.tgarch,"std")
t_std_AE_ES <- t_std_ES[2]
t_std_AE_p <- t_std_ES[[3]] 

t_norm_ES <- ESTesting(tgarch.normback, VaR.norm.tgarch,"norm")
t_norm_AE_ES <- t_norm_ES[2]
t_norm_AE_p <- t_norm_ES[[3]]

#ES for nagarch

na_sged_ES <- ESTesting(nagarch.sgedback, VaR.sged.nagarch,"sged")
na_sged_AE_ES <- na_sged_ES[2]
na_sged_AE_p <- na_sged_ES[[3]] 

na_ged_ES <- ESTesting(nagarch.gedback, VaR.ged.nagarch,"ged")
na_ged_AE_ES <- na_ged_ES[2]
na_ged_AE_p <- na_ged_ES[[3]] 

na_sstd_ES <- ESTesting(nagarch.sstdback, VaR.sstd.nagarch,"sstd")
na_sstd_AE_ES <- na_sstd_ES[2]
na_sstd_AE_p <- na_sstd_ES[[3]] 

na_std_ES <- ESTesting(nagarch.sstdback, VaR.std.nagarch,"std")
na_std_AE_ES <- na_std_ES[2]
na_std_AE_p <- na_std_ES[[3]] 

na_norm_ES <- ESTesting(nagarch.normback, VaR.norm.nagarch,"norm")
na_norm_AE_ES <- na_norm_ES[2]
na_norm_AE_p <- na_norm_ES[[3]]

#ES for avgarch

av_sged_ES <- ESTesting(avgarch.sgedback, VaR.sged.avgarch,"sged")
av_sged_AE_ES <- av_sged_ES[2]
av_sged_AE_p <- av_sged_ES[[3]] 

av_ged_ES <- ESTesting(avgarch.gedback, VaR.ged.avgarch,"ged")
av_ged_AE_ES <- av_ged_ES[2]
av_ged_AE_p <- av_ged_ES[[3]] 

av_sstd_ES <- ESTesting(avgarch.sstdback, VaR.sstd.avgarch,"sstd")
av_sstd_AE_ES <- av_sstd_ES[2]
av_sstd_AE_p <- av_sstd_ES[[3]] 

av_std_ES <- ESTesting(avgarch.sstdback, VaR.std.avgarch,"std")
av_std_AE_ES <- av_std_ES[2]
av_std_AE_p <- av_std_ES[[3]] 

av_norm_ES <- ESTesting(avgarch.normback, VaR.norm.avgarch,"norm")
av_norm_AE_ES <- av_norm_ES[2]
av_norm_AE_p <- av_norm_ES[[3]]
```

```{r table4prep, eval=F}

e_sged <- gettests(VaR.sged.egarch)
e_ged <- gettests(VaR.ged.egarch)
e_sstd <- gettests(VaR.sstd.egarch)
e_std <- gettests(VaR.std.egarch)
e_norm <- gettests(VaR.norm.egarch)

gjr_sged <- gettests(VaR.sged.gjrgarch)
gjr_ged <- gettests(VaR.ged.gjrgarch)
gjr_sstd <- gettests(VaR.sstd.gjrgarch)
gjr_std <- gettests(VaR.std.gjrgarch)
gjr_norm <- gettests(VaR.norm.gjrgarch)

t_sged <- gettests(VaR.sged.tgarch)
t_ged <- gettests(VaR.ged.tgarch)
t_sstd <- gettests(VaR.sstd.tgarch)
t_std <- gettests(VaR.std.tgarch)
t_norm <- gettests(VaR.norm.tgarch)

na_sged <- gettests(VaR.sged.nagarch)
na_ged <- gettests(VaR.ged.nagarch)
na_sstd <- gettests(VaR.sstd.nagarch)
na_std <- gettests(VaR.std.nagarch)
na_norm <- gettests(VaR.norm.nagarch)

av_sged <- gettests(VaR.sged.avgarch)
av_ged <- gettests(VaR.ged.avgarch)
av_sstd <- gettests(VaR.sstd.avgarch)
av_std <- gettests(VaR.std.avgarch)
av_norm <- gettests(VaR.norm.avgarch)

#TABLE LAYOUT 

table_tests <- matrix(nrow=30,ncol=5)
rownames(table_tests) <- c("SGED","AE_var","AE_ES", "UC","CC","DQ","GED","AE_var","AE_ES","UC","CC","DQ","ST","AE_var","AE_ES","UC","CC","DQ","T","AE_var","AE_ES","UC","CC","DQ","Norm","AE_var","AE_ES","UC","CC","DQ")
colnames(table_tests) <- c("eGarch","gjrGarch","tGarch","naGarch","avGarch")
table_tests <- as.data.frame(table_tests)
#STATISTICS

table_tests[2,] <- c(e_sged$ae, gjr_sged$ae,t_sged$ae,na_sged$ae,av_sged$ae)
table_tests[3,] <- c(as.numeric(e_sged_AE_ES), as.numeric(gjr_sged_AE_ES), as.numeric(t_sged_AE_ES), as.numeric(na_sged_AE_ES), as.numeric(av_sged_AE_ES))
table_tests[4,] <- c(e_sged$uc[1], gjr_sged$uc[1],t_sged$uc[1],na_sged$uc[1],av_sged$uc[1])
table_tests[5,] <- c(e_sged$cc[1], gjr_sged$cc[1],t_sged$cc[1],na_sged$cc[1],av_sged$cc[1])
table_tests[6,] <- c(e_sged$dq$stat, gjr_sged$dq$stat,t_sged$dq$stat,na_sged$dq$stat,av_sged$dq$stat)
table_tests[8,]<- c(e_ged$ae, gjr_ged$ae,t_ged$ae,na_ged$ae,av_ged$ae)
table_tests[9,] <- c(as.numeric(e_ged_AE_ES), as.numeric(gjr_ged_AE_ES), as.numeric(t_ged_AE_ES), as.numeric(na_ged_AE_ES), as.numeric(av_ged_AE_ES))
table_tests[10,]<- c(e_ged$uc[1], gjr_ged$uc[1],t_ged$uc[1],na_ged$uc[1],av_ged$uc[1])
table_tests[11,]<- c(e_ged$cc[1], gjr_ged$cc[1],t_ged$cc[1],na_ged$cc[1],av_ged$cc[1])
table_tests[12,]<- c(e_ged$dq$stat, gjr_ged$dq$stat,t_ged$dq$stat,na_ged$dq$stat,av_ged$dq$stat)
table_tests[14,]<- c(e_sstd$ae, gjr_sstd$ae,t_sstd$ae,na_sstd$ae,av_sstd$ae)
table_tests[15,] <- c(as.numeric(e_sstd_AE_ES), as.numeric(gjr_sstd_AE_ES), as.numeric(t_sstd_AE_ES), as.numeric(na_sstd_AE_ES), as.numeric(av_sstd_AE_ES))
table_tests[16,]<- c(e_sstd$uc[1], gjr_sstd$uc[1],t_sstd$uc[1],na_sstd$uc[1],av_sstd$uc[1])
table_tests[17,]<- c(e_sstd$cc[1], gjr_sstd$cc[1],t_sstd$cc[1],na_sstd$cc[1],av_sstd$cc[1])
table_tests[18,]<- c(e_sstd$dq$stat, gjr_sstd$dq$stat,t_sstd$dq$stat,na_sstd$dq$stat,av_sstd$dq$stat)
table_tests[20,]<- c(e_std$ae, gjr_std$ae,t_std$ae,na_std$ae,av_std$ae)
table_tests[21,] <- c(as.numeric(e_std_AE_ES), as.numeric(gjr_std_AE_ES), as.numeric(t_std_AE_ES), as.numeric(na_std_AE_ES), as.numeric(av_std_AE_ES))
table_tests[22,]<- c(e_std$uc[1], gjr_std$uc[1],t_std$uc[1],na_std$uc[1],av_std$uc[1])
table_tests[23,]<- c(e_std$cc[1], gjr_std$cc[1],t_std$cc[1],na_std$cc[1],av_std$cc[1])
table_tests[24,]<- c(e_std$dq$stat, gjr_std$dq$stat,t_std$dq$stat,na_std$dq$stat,av_std$dq$stat)
table_tests[26,]<- c(e_norm$ae, gjr_norm$ae,t_norm$ae,na_norm$ae,av_norm$ae)
table_tests[27,] <- c(as.numeric(e_norm_AE_ES), as.numeric(gjr_norm_AE_ES), as.numeric(t_norm_AE_ES), as.numeric(na_norm_AE_ES), as.numeric(av_norm_AE_ES))
table_tests[28,]<- c(e_norm$uc[1], gjr_norm$uc[1],t_norm$uc[1],na_norm$uc[1],av_norm$uc[1])
table_tests[29,]<- c(e_norm$cc[1], gjr_norm$cc[1],t_norm$cc[1],na_norm$cc[1],av_norm$cc[1])
table_tests[30,]<- c(e_norm$dq$stat, gjr_norm$dq$stat,t_norm$dq$stat,na_norm$dq$stat,av_norm$dq$stat)

uc.signific <- function(x) {
  if(x$uc[2]<0.1)  y = "*"
  if(x$uc[2]<0.05) y = "**"
  if(x$uc[2]<0.01) y = "***"
  else if(x$uc[2]>0.1) y = ""
  return(y)
}
cc.signific <- function(x) {
  if(x$cc[2]<0.1)  y = "*"
  if(x$cc[2]<0.05) y = "**"
  if(x$cc[2]<0.01) y = "***"
  else if(x$cc[2]>0.1) y = ""
  return(y)
}

dq.signific <- function(x) {
  if(x$dq$pvalue<0.1)  y = "*"
  if(x$dq$pvalue<0.05) y = "**"
  if(x$dq$pvalue<0.01) y = "***"
  else if(x$dq$pvalue>0.1) y = ""
  return(y)
}

ES.signific <- function(x) {
  if(x<0.1)  y = "*"
  if(x<0.05) y = "**"
  if(x<0.01) y = "***"
  else if(x>0.1) y = ""
  return(y)
}
#PVALUES LOOPS
r3 <- c(ES.signific(e_sged_AE_p),ES.signific(gjr_sged_AE_p),ES.signific(t_sged_AE_p),ES.signific(na_sged_AE_p),ES.signific(av_sged_AE_p))
r4 <- c(uc.signific(e_sged),uc.signific(gjr_sged),uc.signific(t_sged),uc.signific(na_sged),uc.signific(av_sged))
r5 <- c(cc.signific(e_sged),cc.signific(gjr_sged),cc.signific(t_sged),cc.signific(na_sged),cc.signific(av_sged))
r6 <- c(dq.signific(e_sged),dq.signific(gjr_sged),dq.signific(t_sged),dq.signific(na_sged),dq.signific(av_sged))

r9 <- c(ES.signific(e_ged_AE_p),ES.signific(gjr_ged_AE_p),ES.signific(t_ged_AE_p),ES.signific(na_ged_AE_p),ES.signific(av_ged_AE_p))
r10 <- c(uc.signific(e_ged),uc.signific(gjr_ged),uc.signific(t_ged),uc.signific(na_ged),uc.signific(av_ged))
r11 <- c(cc.signific(e_ged),cc.signific(gjr_ged),cc.signific(t_ged),cc.signific(na_ged),cc.signific(av_ged))
r12 <- c(dq.signific(e_ged),dq.signific(gjr_ged),dq.signific(t_ged),dq.signific(na_ged),dq.signific(av_ged))

r15 <- c(ES.signific(e_sstd_AE_p),ES.signific(gjr_sstd_AE_p),ES.signific(t_sstd_AE_p),ES.signific(na_sstd_AE_p),ES.signific(av_sstd_AE_p))
r16 <- c(uc.signific(e_sstd),uc.signific(gjr_sstd),uc.signific(t_sstd),uc.signific(na_sstd),uc.signific(av_sstd))
r17 <- c(cc.signific(e_sstd),cc.signific(gjr_sstd),cc.signific(t_sstd),cc.signific(na_sstd),cc.signific(av_sstd))
r18 <- c(dq.signific(e_sstd),dq.signific(gjr_sstd),dq.signific(t_sstd),dq.signific(na_sstd),dq.signific(av_sstd))

r21 <- c(ES.signific(e_std_AE_p),ES.signific(gjr_std_AE_p),ES.signific(t_std_AE_p),ES.signific(na_std_AE_p),ES.signific(av_std_AE_p))
r22 <- c(uc.signific(e_std),uc.signific(gjr_std),uc.signific(t_std),uc.signific(na_std),uc.signific(av_std))
r23 <- c(cc.signific(e_std),cc.signific(gjr_std),cc.signific(t_std),cc.signific(na_std),cc.signific(av_std))
r24 <- c(dq.signific(e_std),dq.signific(gjr_std),dq.signific(t_std),dq.signific(na_std),dq.signific(av_std))

r27 <- c(ES.signific(e_norm_AE_p),ES.signific(gjr_norm_AE_p),ES.signific(t_norm_AE_p),ES.signific(na_norm_AE_p),ES.signific(av_norm_AE_p))
r28 <- c(uc.signific(e_norm),uc.signific(gjr_norm),uc.signific(t_norm),uc.signific(na_norm),uc.signific(av_norm))
r29 <- c(cc.signific(e_norm),cc.signific(gjr_norm),cc.signific(t_norm),cc.signific(na_norm),cc.signific(av_norm))
r30 <- c(dq.signific(e_norm),dq.signific(gjr_norm),dq.signific(t_norm),dq.signific(na_norm),dq.signific(av_norm))

table_tests[2,] <- paste0(round(table_tests[2,],3),"") #placeholder
table_tests[3,] <- paste0(round(as.numeric(table_tests[3,]),3),r3)
table_tests[4,] <- paste0(round(as.numeric(table_tests[4,]),3),r4)
table_tests[5,] <- paste0(round(as.numeric(table_tests[5,]),3),r5)
table_tests[6,] <- paste0(round(as.numeric(table_tests[6,]),3),r6)
table_tests[8,] <- paste0(round(as.numeric(table_tests[8,]),3),"")
table_tests[9,] <- paste0(round(as.numeric(table_tests[9,]),3),r9)
table_tests[10,] <- paste0(round(as.numeric(table_tests[10,]),3),r10)
table_tests[11,] <- paste0(round(as.numeric(table_tests[11,]),3),r11)
table_tests[12,] <- paste0(round(as.numeric(table_tests[12,]),3),r12)
table_tests[14,] <- paste0(round(as.numeric(table_tests[14,]),3),"")
table_tests[15,] <- paste0(round(as.numeric(table_tests[15,]),3),r15)
table_tests[16,] <- paste0(round(as.numeric(table_tests[16,]),3),r16)
table_tests[17,] <- paste0(round(as.numeric(table_tests[17,]),3),r17)
table_tests[18,] <- paste0(round(as.numeric(table_tests[18,]),3),r18)
table_tests[20,] <- paste0(round(as.numeric(table_tests[20,]),3),"")
table_tests[21,] <- paste0(round(as.numeric(table_tests[21,]),3),r21)
table_tests[22,] <- paste0(round(as.numeric(table_tests[22,]),3),r22)
table_tests[23,] <- paste0(round(as.numeric(table_tests[23,]),3),r23)
table_tests[24,] <- paste0(round(as.numeric(table_tests[24,]),3),r24)
table_tests[26,] <- paste0(round(as.numeric(table_tests[26,]),3),"")
table_tests[27,] <- paste0(round(as.numeric(table_tests[27,]),3),r27)
table_tests[28,] <- paste0(round(as.numeric(table_tests[28,]),3),r28)
table_tests[29,] <- paste0(round(as.numeric(table_tests[29,]),3),r29)
table_tests[30,] <- paste0(round(as.numeric(table_tests[30,]),3),r30)

#KABLE OUTPUT
df <- table_tests[-c(1,7,13,19,25),] %>% as.data.frame()
colnames(df) <- c("EGARCH", "GJRGARCH", "TGARCH", "NAGARCH", "AVGARCH")
df <- as.matrix(df)
rownames(df) <- c("AE VaR","AE CVaR", "UC","CC","DQ","AE VaR","AE CVaR","UC","CC","DQ","AE CVaR","AE CVaR","UC","CC","DQ","AE VaR","AE CVaR","UC","CC","DQ","AE VaR","AE CVaR","UC","CC","DQ")
# writexl::write_xlsx(df, "findings/table4.xlsx")
```

```{r table4, echo=F, results='asis'}
df %>% kbl(booktabs=T,
           caption = "VaR and CVaR test statistics",
      label = 'Table4',row.names = T) %>%
  kable_styling() %>%
  kable_classic(full_width = F)%>%
  pack_rows("Panel A: SGED", 1,5) %>%
  pack_rows("Panel B: GED", 6,10) %>%
  pack_rows("Panel C: ST", 11,15) %>%
  pack_rows("Panel D: T", 16,20) %>%
  pack_rows("Panel E: N", 21,25) %>% add_indent(c(1:17, 18:25)) %>%
  footnote(general = "Table contains the ratio of actual to expected exceedances for VaR and Conditional VaR, the unconditional and conditional coverage test statistic and the dynamic quantile test statistic for VaR. Significance levels for the VaR ratio not reported. *, ** and *** point out significance at 10, 5 and 1 percent level.",threeparttable = T,footnote_as_chunk = F, escape=F, general_title = "Notes:") 
```

\clearpage 
```{r acdcode, eval = FALSE}
# ACD specification
spec = racd::acdspec(mean.model = list(armaOrder = c(1, 0)), variance.model = list(variance.targeting = TRUE),distribution.model = list(model = 'sstd', skewOrder = c(1, 1, 1), shapeOrder = c(1,1,1), skewmodel = 'pwl', shapemodel = 'pwl'))

# sGARCH, takes 2.5 minutes
fit = racd::acdfit(spec, R, solver = 'msoptim', solver.control = list(restarts = 10)) #starts from different starting values to find an optimum
```


```{r Table5prep, eval=F}
object <- fit@fit$robust.matcoef
rownames(object) <- revalue(rownames(object),c("mu"="$\\alpha_0$", "ar1"="$\\alpha_1$", "omega"= "$\\beta_0$", "alpha1"="$\\beta_1$", "beta1"="$\\beta_2$", "skcons"="$\\chi_0$", "skalpha1"="$\\chi_1$", "skgamma1"="$\\chi_2$", "skbeta1"="$\\xi_1$", "shcons" = "$\\kappa_{0}$","shalpha1"="$\\kappa_{1}$","shgamma1"= "$\\kappa_{2}$",  "shbeta1"="$\\psi_{1}$"))
object <- round(object[,-3],3)

object[which(object[,3]>=0.10),2] <- paste0("(",object[which(object[,3]>=0.10),2],")")
object[which(object[,3]<0.10&object[,3]>0.05),2] <- paste0("(",object[which(object[,3]<0.10&object[,3]>0.05),2],")*")
object[which(object[,3]<=0.05&object[,3]>0.01),2] <- paste0("(",object[which(object[,3]<=0.05&object[,3]>0.01),2],")**")
object[which(object[,3]<=0.01),2] <- paste0("(",object[which(object[,3]<=0.01),2],")***")
object.df <- as.data.frame(object[,-3])
object.df[is.na(object.df)] <- ""
colnames(object.df) <- c("ACD GARCH" , "")

object.df <- rbind(object.df[c(1,2),],object.df[rownames(object.df)=="$\\beta_0$",],object.df[-c(1,2,rownames(object.df)=="$\\beta_0$"),])[-nrow(rbind(object.df[c(1,2),],object.df[rownames(object.df)=="$\\beta_0$",],object.df[-c(1,2,rownames(object.df)=="$\\beta_0$"),])),]
```


```{r Table5, echo=F, results='asis'}
#require(magrittr)
fn1.3c <- sprintf(paste0('This table shows the maximum likelihood estimates of the ST-ACD model. The daily returns used on the ',stringr::str_to_title(gsub(pattern = '\\.', replacement=' ',colnames(R)))," Price index cover the period from ",gsub(" UTC", "",format(min(index(R)), '%d %B, %Y'))," to ",gsub(" UTC", "",format(max(index(R)),'%d %B, %Y')), " (", nrow(R)," observations)."))
fn2.3 <- "The mean process is modeled as follows: $R_t= \\\\alpha_0+ \\\\alpha_1 \\\\times R_{t-1}+ \\\\varepsilon_t$. Where, in the model estimated, $\\\\gamma$ is the asymmetry in volatility,  (calculated using robust standard errors based on the method of White (1982)) are displayed in parenthesis."

table5 <- data.frame(paste(object.df[,1]," ", object.df[,2]))
colnames(table5) <- "ACD-GARCH"
rownames(table5) <- rownames(object.df) 
table5 %>% kbl(col.names = toupper(colnames(object.df)[1]),caption = "Maximum likelihood estimates of the ST-ACD model with constant skewness and kurtosis parameters",format = "latex",
      label = 'Table5',
      booktabs = TRUE, row.names = T, escape = F) %>%
  kable_classic(full_width = F) %>%
  footnote(general = c(fn1.3b,fn2.3),threeparttable=T,footnote_as_chunk = F, escape=F, general_title = "Notes:") %>% column_spec(1, width = "4cm") %>% column_spec(2, width = "7cm")
```

```{r acdbacktest, eval=FALSE}
spec = racd::acdspec(mean.model = list(armaOrder = c(1, 0)), variance.model = list(variance.targeting = TRUE),distribution.model = list(model = 'sstd', skewOrder = c(1, 1, 1), shapeOrder = c(1,1,1), skewmodel = 'pwl', shapemodel = 'pwl'))

# Backtest ----
rollacd = racd::acdroll(spec, R, n.start = 2800, refit.every = 250, refit.window = 'recursive', calculate.VaR = TRUE, VaR.alpha = 0.01)
# racd::convergence(rollacd)
# Benchmark ----
gspec = ugarchspec(mean.model = list(armaOrder = c(1, 0)), variance.model = list(variance.targeting = TRUE), distribution = 'sstd')
rollg = ugarchroll(gspec, R, n.start = 2800, refit.every = 250, refit.window = 'recursive')
```

```{r acdbacktestresults, echo=FALSE}
# Table
# VaRTest----
vartable = rbind(
  as.data.frame(
    VaRTest(alpha = 0.01, 
          actual =rollacd@forecast$VaR[,'realized'], 
          VaR = rollacd@forecast$VaR[, 'alpha(1%)']), 
  row.names =c('ACD(1%)')),
  as.data.frame(
    VaRTest(alpha = 0.01, 
            actual = rollg@forecast$VaR[, 'realized'],
            VaR = rollg@forecast$VaR[, 'alpha(1%)']), 
    row.names = c('GARCH(1%)')))

vartable2 <- vartable %>% mutate(AE = actual.exceed/expected.exceed)
vartable2 <- vartable2 %>% select(AE, uc.LRstat, uc.LRp, cc.LRstat, cc.LRp)
vartable2 <- round(vartable2,3)

vartable2[1,2] <- paste0(vartable2[1,2],signific(vartable2[1,3]))
vartable2[2,2] <- paste0(vartable2[2,2],signific(vartable2[2,3]))

vartable2[1,4] <- paste0(vartable2[1,4],signific(vartable2[1,4]))
vartable2[2,4] <- paste0(vartable2[2,4],signific(vartable2[2,4]))

vartable2 <- vartable2 %>% select(AE,uc.LRstat, cc.LRstat)

# ESTest modified----
ESTestingACD <- function(acd.back, var, dist){
  roll <- rollacd@forecast$density
  f <- function(x, skew, shape) qdist(dist, p = x, mu = 0, sigma = 1, skew = skew, shape = shape)
  #VaR in same fashion as ES below, and gives the same VaR as previously found so it is redundant.
  # VaR <- roll[,'Mu'] + qdist(dist, 0.01, mu = 0, sigma =1, skew = roll[,'Skew'], shape = roll[,'Shape']) * roll[,'Sigma']
  ES <- roll['Mu'] + roll['Sigma']*apply(roll, 1, function(x)
    integrate(f,0,0.01, skew = x['Skew'], shape = x['Shape'])$value/0.01)
  names(ES) <- "ES"
  ESTest_object <- ESTest(0.01, R[-c(1:2800),], ES[,1], var, conf.level = 0.99, boot = T)
  # length(R)
  # nrow(ES)
  # length(VaR.sstd.egarch)
  AE_ES <- as.numeric(ESTest_object[2])/as.numeric(ESTest_object[1])
  AE_ES.p <- ESTest_object[4] #bootstrapped p-value
  return(list(ES,AE_ES,AE_ES.p))
}
sacd_sstd_ES <- ESTestingACD(rollacd, var = as.vector(rollacd@forecast$VaR$`alpha(1%)`), "sstd")

ESTesting2 <- function(garch.back, var, dist){
  
  roll <- as.data.frame(garch.back, which = "density",)
  f <- function(x, skew, shape) qdist(dist, p = x, mu = 0, sigma = 1, skew = skew, shape = shape)
  #VaR in same fashion as ES below, and gives the same VaR as previously found so it is redundant.
  # VaR <- roll[,'Mu'] + qdist(dist, 0.01, mu = 0, sigma =1, skew = roll[,'Skew'], shape = roll[,'Shape']) * roll[,'Sigma']
  ES <- roll['Mu'] + roll['Sigma']*apply(roll, 1, function(x)
    integrate(f,0,0.01, skew = x['Skew'], shape = x['Shape'])$value/0.01)
  names(ES) <- "ES"
  ESTest_object <- ESTest(0.01, R[-c(1:2800),], ES[,1], var, conf.level = 0.99, boot = T)
  # length(R)
  # nrow(ES)
  # length(VaR.sstd.egarch)
  AE_ES <- as.numeric(ESTest_object[2])/as.numeric(ESTest_object[1])
  AE_ES.p <- ESTest_object[4] #bootstrapped p-value
  return(list(ES,AE_ES,AE_ES.p))
}
sgarchnonacd_sstd_ES <- ESTesting2(rollg, var = rollg@forecast$VaR$`alpha(1%)`, "sstd")

sacd_sstd_AE_ES <- sacd_sstd_ES[2]
sacd_sstd_AE_p <- sacd_sstd_ES[[3]] 
sacd_sstd_AE_ES <-paste0(round(sacd_sstd_AE_ES[[1]],3), signific(sacd_sstd_AE_p))

sgarchnonacd_sstd_AE_ES <- sgarchnonacd_sstd_ES[2]
sgarchnonacd_sstd_AE_p <- sgarchnonacd_sstd_ES[[3]] 
sgarchnonacd_sstd_AE_ES <-paste0(round(sgarchnonacd_sstd_AE_ES[[1]],3), signific(sgarchnonacd_sstd_AE_p))

# DQ Test
DQ_ACD <- BacktestVaR(R[2801:nrow(R)],rollacd@forecast$VaR$`alpha(1%)`,0.01, 5)$DQ
DQ_nonacd <- BacktestVaR(R[2801:nrow(R)],rollg@forecast$VaR$`alpha(1%)`,0.01, 5)$DQ

DQ_ACD_stat <- paste0(round(DQ_ACD$stat,3), signific(DQ_ACD$pvalue))
DQ_nonacd_stat <- paste0(round(DQ_nonacd$stat,3), signific(DQ_nonacd$pvalue))

table_tests_acd <- matrix(nrow=5,ncol=2)
rownames(table_tests_acd) <- c("AE VaR","AE CVaR", "UC","CC", "DQ")
colnames(table_tests_acd) <- c("ACD", "GARCH")

table_tests_acd[1,] <- vartable2[,1]
table_tests_acd[2,] <- c(sacd_sstd_AE_ES,sgarchnonacd_sstd_AE_ES)
table_tests_acd[3,] <- vartable2[,2]
table_tests_acd[4,] <- vartable2[,3]
table_tests_acd[5,] <- c(DQ_ACD_stat,DQ_nonacd_stat)
```

\newpage

```{r tableACDBacktest, echo = FALSE, results='asis'}
table_tests_acd %>% kbl(booktabs=T,format="latex",
           caption = "VaR and ES test statistics (ACD-ST vs GARCH-ST)",
      label = 'tableACDBacktest',row.names = T) %>%
  kable_styling() %>%
  kable_classic(full_width = F)%>%
  footnote(general = "Table contains the ratio of actual to expected exceedances for VaR and Expected Shortfall, the unconditional and conditional coverage test statistic and the dynamic quantile test statistic for VaR. Significance levels for the VaR ratio not reported. *, ** and *** point out significance at 10, 5 and 1 percent level.",threeparttable = T, footnote_as_chunk = F, escape=F, general_title = "Notes:") %>% column_spec(1, width = "3cm") %>% column_spec(2, width = "4cm") %>% column_spec(3, width = "4cm")
```

```{r lbtableprep, echo=FALSE, results='asis'}
#LJUNG-BOX TEST ON STANDARDIZED SQUARED RESIDUALS
#create a function to make Lj box test for squared residuals(((Change the number 22 into how many days back you want to test)))

LJ.test.df.2 <- Table.tests.function(Lj.box.test.function.2, return.matrix = F)
LJ.test.df.all <- LJ.test.df.2
LJ.test.df.all <- as.matrix(LJ.test.df.all)
```


```{r archlmtableprep, echo=FALSE}
#SIGNbias <- signbias(garchfit.sGARCH[[1]])
#Nyblom <- nyblom(garchfit.sGARCH[[1]])
#t.test(rugarch::residuals(garchfit.sGARCH[[1]], standardize = T), mu = 0)
#jarqueberaTest(rugarch::residuals(garchfit.eGARCH[[1]], standardize = T))
#lillieTest(rugarch::residuals(garchfit.eGARCH[[1]], standardize = T))
#WeightedPortTest::Weighted.LM.test(garchfit.eGARCH[[1]]@fit$residuals, garchfit.eGARCH[[1]]@fit$sigma, lag = 22) #Li Mak test

#ARCH lm TEST
ARCH.lm.Test.df <- Table.tests.function(archlmtest, return.matrix = T)

# ARCH.lm.Test.df %>% kbl(caption = "ARCH LM Test",
#       label = 'ARCHLMTable',
#       booktabs = T,
#       position = "h!",
#       digits = 3 )%>%
#   kable_classic(full_width = F)%>%
#   footnote(general = "Notes",number=c("This table shows the ARCH LM statistics value for the respective model", "DESCRIBE PVALUES ***, **, *"),threeparttable = T,footnote_as_chunk = F, escape=F, general_title = "") %>%
#   kable_styling(latex_options = "scale_down") %>% landscape()

# install.packages("FinTS")
# FinTS::ArchTest(rugarch::residuals(garchfit.eGARCH[[1]], standardize = T), lags = 22)
```

```{r heterosctable, results='asis'}
heterosc.all <- rbind(LJ.test.df.all, ARCH.lm.Test.df)
heterosc.all %>% kbl(caption = "Diagnostic Tests for Heteroscedasticity",
      label = 'LjboxTable',
      booktabs = T,
      position = "h!",
      digits = 3 )%>%
  kable_classic(full_width = F)%>%
  pack_rows("Panel A: Ljung Box Test on the standardized squared values of the residuals", 1,5) %>% 
  pack_rows("Panel B: ARCH LM Test on the standardized squared values of the residuals", 6,10) %>%
  footnote(general_title = "Notes",general=c(paste0("Table displays the Ljung box statistics and the ARCH LM Test for the standardized squared residuals of the models analyzed. The underlying data is the daily return series of the France CAC 40 for the period between ", format(min(index(R)))," and ",format(max(index(R))),"."), "*, ** and *** point out respectively significance at 10, 5 and 1 percent level.", "The null hypothesis of the test in both panels are described as follows:","$H_0$: $Corr$($Z_t^2$,$Z_{t-1}^2$)=$Corr$($Z_t^2$,$Z_{t-2}^2$)= $...$ =$Corr$($Z_t^2$,$Z_{t-22}^2$) = $0$"),threeparttable = T,footnote_as_chunk = F, escape=F) %>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

```{r gmmtestprep, echo=F}
#GMM test
GMM.mean <- GMM.table.function(function.to.apply = GMMTest.2, return.matrix = T, col.numb = 1)
GMM.var <- GMM.table.function(function.to.apply = GMMTest.2, return.matrix = T, col.numb = 2)
GMM.skew <- GMM.table.function(function.to.apply = GMMTest.2, return.matrix = T, col.numb = 3)
GMM.kurt <- GMM.table.function(function.to.apply = GMMTest.2, return.matrix = T, col.numb = 4)

GMM.norm <- rbind(GMM.mean[1,],GMM.var[1,],GMM.skew[1,],GMM.kurt[1,])
GMM.t <- rbind(GMM.mean[2,],GMM.var[2,],GMM.skew[2,],GMM.kurt[2,])
GMM.st <- rbind(GMM.mean[3,],GMM.var[3,],GMM.skew[3,],GMM.kurt[3,])
GMM.ged <- rbind(GMM.mean[4,],GMM.var[4,],GMM.skew[4,],GMM.kurt[4,])
GMM.sged <- rbind(GMM.mean[5,],GMM.var[5,],GMM.skew[5,],GMM.kurt[5,])

rownames(GMM.norm) <- rownames(GMM.t) <- rownames(GMM.st) <- rownames(GMM.ged) <- rownames(GMM.sged) <- c("Mean", "Variance", "Skewness", "Excess Kurtosis")
GMM.all <- rbind(GMM.sged,GMM.ged,GMM.st,GMM.t,GMM.norm)
```

```{r gmmtable, echo=F}
GMM.all %>% kbl(caption = "GMM Tests",format = "latex",
      label = 'GMMtable',
      booktabs = T,
      position = "h!",
      digits = 3 )%>%
  kable_classic(full_width = F)%>%
  pack_rows("Panel A: SGED", 1,4) %>%
  pack_rows("Panel B: GED", 5,8) %>%
  pack_rows("Panel C: ST", 9,12) %>%
  pack_rows("Panel D: T", 13,16) %>%
  pack_rows("Panel E: N", 17,20) %>%
  footnote(general_title = "Notes",general=c(paste0("Table displays the GMM test statistics for the standardized residuals. The underlying data is the daily return series of the France CAC 40 for the period between ", format(min(index(R)))," and ",format(max(index(R))),"."), "The null hypothesis of the test for each variable are described as follows: $H_0: $ $E[z_{t}] = 0$ for the mean, $H_0: $ $E[z_{t}^2-1] = 0$ for the variance. $H_0: $ $E[z_{t}^3] = 0$ for the skewness and $H_0: $ $E[z_{t}^4-3] = 0$ for the excess kurtosis."),threeparttable = T,footnote_as_chunk = T, escape=F) %>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

```{r JBtable, echo=F, results="asis"}
#create a function to make JB test for residuals(((Change the number 22 into how many days back you want to test)))

JB.test.df <- suppressWarnings(Table.tests.function(Jarque.bera.test.function, return.matrix = T))
 JB.test.df %>% kbl(caption = "Jarque-Bera Test on standardized residuals",format="latex",
      label = 'JBTable',
      booktabs = T,
      position = "h!",
      digits = 3 )%>%
  kable_classic(full_width = F)%>%
  footnote(general_title = "Notes",general=c(paste0("Table displays the Jarque-Bera statistic $JB=\\\\frac{n}{6}(S^{2}+\\\\frac{1}{4}(K-3)^{2})$ with $n$ the sample size, $K$ the kurtosis and $S$ the skewness for the residuals of the models. The JB statistic is distributed $\\\\chi^2$ with $\\\\nu = 2$. The underlying data is the daily return series of the France CAC 40 for the period between ", format(min(index(R)))," and ",format(max(index(R))),"."), "*, ** and *** point out respectively significance at 10, 5 and 1 percent level.", "The null hypothesis is that $S$ and $K$ are not significantly different than what would be found under normality (0 and 3)."),threeparttable = T,footnote_as_chunk = T, escape=F) %>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

<!-- #WeightedPortTest::Weighted.LM.test(rugarch::residuals(garchfit.eGARCH[[1]]), sigma(garchfit.eGARCH[[1]]), lag = 22) -->

<!-- ``` -->


```{r figuresqq, fig.cap="QQ plots of AVGARCH residuals versus the standardized returns of the series",fig.align='center', out.width="100%",fig.pos="h",echo=F}
par(mfrow = c(1,2), mar = c(5.1, 4.1, 2.1, 2.1))
qqnorm(rugarch::residuals(garchfit.fGARCH.AVGARCH[[4]], standardize = T), main = "AVGARCH Residuals")
qqline(rugarch::residuals(garchfit.fGARCH.AVGARCH[[4]], standardize = T))
qqnorm(scale(R), main = "Raw standardized returns")
qqline(scale(R))

# plot(density(rugarch::residuals(garchfit.fGARCH.AVGARCH[[4]], standardize = T)), lwd = 2, main = "AV GARCH Residuals")
# curve(dnorm(x, mean=mean(rugarch::residuals(garchfit.fGARCH.AVGARCH[[4]], standardize = T)), sd=sd(rugarch::residuals(garchfit.fGARCH.AVGARCH[[4]], standardize = T))), 
#       col="cornflowerblue", lwd=2, add=TRUE, yaxt="n")
# plot(density(scale(R)), lwd = 2, main = "Raw standardized returns")
# curve(dnorm(x, mean=0, sd=sd(scale(R))), 
#       col="cornflowerblue", lwd=2, add=TRUE, yaxt="n")

```

```{r}
#save.image(file='CAC40.RData')
```

