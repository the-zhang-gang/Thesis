---
output:
  bookdown::pdf_document2:
    template: templates/brief_template.tex
    citation_package: biblatex
  #bookdown::word_document2: default
  #bookdown::html_document2: default
documentclass: book
bibliography: references.bib
---

# Empirical Findings {#analysis}

\minitoc <!-- this will include a mini table of contents-->

```{r}
require(readxl)
require(xts)
require(PerformanceAnalytics)
require(kableExtra)
require(rugarch)
require(fitdistrplus)
require(fGarch) 
require(tree)  # do we need this?
require(sgt)
require(devtools)
install_bitbucket("alexiosg/racd")
require(racd)
require(readxl)
require(xts)
require(parallel)
data <- read_excel("data/datastream.xlsx",col_types = c("date", rep("numeric", 6)),skip = 2) #warnings are NA's
colnames(data) <- c("Date",gsub(pattern = " - PRICE INDEX", replacement='' , colnames(data)[2:7]))
Price_indices <- as.xts(data[,-1], order.by = data$Date)
Estoxx <- Price_indices[,1] #see if price index
R <- diff(Estoxx, log = TRUE, na.pad = FALSE)*100
```

## Results of GARCH with constant higher moments

<!--# Here comes our main part [FILIPPO] -> to do!  -->

```{r}
distributions <- c("norm", "std", "sstd", "sged", "ged")
#garchspec <- garchfit <- garchforecast <- stdret <- vector(mode = "list", length = length(distributions))
#names(garchspec) <- names(garchfit) <- names(garchforecast) <- names(stdret) <- distributions
Models.garch <- c("sGARCH", "eGARCH","fGARCH", "gjrGARCH", "apARCH", "iGARCH", "csGARCH")

for(i in 1:length(Models.garch)){
assign(paste0("garchspec.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
assign(paste0("garchfit.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
assign(paste0("stdret.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
} 

#.sGARCH--------------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.sGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "sGARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.sGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.sGARCH[[i]])
# Compute stdret using residuals()
stdret.sGARCH[[i]] <- residuals(garchfit.sGARCH[[i]], standardize = TRUE)
}

#.eGARCH-------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.eGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "eGARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.eGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.eGARCH[[i]])
# Compute stdret using residuals()
stdret.eGARCH[[i]] <- residuals(garchfit.eGARCH[[i]], standardize = TRUE)
}

#ERROR BECAUSE NO SUBMODEL SPECIFIED!!!

# #.fGARCH------------------------
# for(i in 1:length(distributions)){
# # Specify a GARCH model with constant mean
# garchspec.fGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
#                      variance.model = list(model = "fGARCH", variance.targeting = F), 
#                      distribution.model = distributions[i])
# # Estimate the model
# garchfit.fGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.fGARCH[[i]])
# # Compute stdret using residuals()
# stdret.fGARCH[[i]] <- residuals(garchfit.fGARCH[[i]], standardize = TRUE)
# }

#.gjrGARCH------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.gjrGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "gjrGARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.gjrGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.gjrGARCH[[i]])
# Compute stdret using residuals()
stdret.gjrGARCH[[i]] <- residuals(garchfit.gjrGARCH[[i]], standardize = TRUE)
}

#.apARCH-------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.apARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "apARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.apARCH[[i]] <- ugarchfit(data = R, spec = garchspec.apARCH[[i]])
# Compute stdret using residuals()
stdret.apARCH[[i]] <- residuals(garchfit.apARCH[[i]], standardize = TRUE)
}

#.iGARCH--------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.iGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "iGARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.iGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.iGARCH[[i]])
# Compute stdret using residuals()
stdret.iGARCH[[i]] <- residuals(garchfit.iGARCH[[i]], standardize = TRUE)
}

#.csGARCH-----------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.csGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "csGARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.csGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.csGARCH[[i]])
# Compute stdret using residuals()
stdret.csGARCH[[i]] <- residuals(garchfit.csGARCH[[i]], standardize = TRUE)
}

#  make the histogram
# 
# chart.Histogram(stdret.iGARCH[[1]], methods = c("add.normal","add.density" ),
#                 colorset = c("gray","red","blue"))
```

## Results of GARCH with time-varying higher moments

```{r}
# ACD specification
sGARCH_ACDspec = acdspec(mean.model = list(armaOrder = c(1, 0)), variance.model = list(variance.targeting = TRUE),
distribution.model = list(model = 'jsu', skewOrder = c(1, 1, 1), shapeOrder = c(1,1,1), skewmodel = 'quad', shapemodel = 'pwl'))

# sGARCH
cl = makePSOCKcluster(10)
fit = acdfit(sGARCH_ACDspec, as.data.frame(R), solver = 'msoptim', solver.control = list(restarts = 10),cluster = cl) #very long process: starts from different starting values to find an optimum
plot2xts = function(x, ...) {
  plot(x, y = NULL, type = 'l',auto.grid = FALSE, major.ticks = 'auto',minor.ticks = FALSE,major.format=FALSE,bar.col = 'grey', candle.col = 'white', ann = TRUE,axes = TRUE, cex.main = 0.9, cex.axis = 0.9,...)
}
par(mfrow = c(2, 2), mai = c(0.75, 0.75, 0.3, 0.3))
plot2xts(fitted(fit), col = 'steelblue', main = 'Conditional Mean')
plot2xts(abs(R), col = 'grey', main = 'Conditional Sigma')
lines(sigma(fit), col = 'steelblue')
plot2xts(skewness(fit), col = 'steelblue', main = 'Skewness')
plot2xts(kurtosis(fit), col = 'steelblue', main = 'Kurtosis (ex)')
```
