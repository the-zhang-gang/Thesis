---
output:
  bookdown::pdf_document2:
    template: templates/brief_template.tex
    citation_package: biblatex
  #bookdown::word_document2: default
  #bookdown::html_document2: default
documentclass: book
bibliography: references.bib
---

# Empirical Findings {#analysis}

\minitoc <!-- this will include a mini table of contents-->

## Density of the returns

```{r librariesfindings, include=F, echo=F}
require(readxl)
require(xts)
require(PerformanceAnalytics)
require(kableExtra)
require(fitdistrplus)
require(fGarch)
require(tree)  # do we need this?
require(sgt)
require(devtools)
require(zoo)
require(stringr)
require(rugarch)
require(plyr)
require(dplyr)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
suppressMessages(install_bitbucket("alexiosg/racd"))
options(knitr.kable.NA = "")
remotes::install_github("R-Finance/xtsExtra")


data <- suppressWarnings(read_excel("data/Price_Return.xlsx", 
    sheet = "Return", col_types = c("date", 
        "numeric", "numeric", "numeric", 
        "numeric"))) #warnings are NA's
colnames(data) <- c("Date", colnames(data)[-1])
indices <- as.xts(data[,-1], order.by = data$Date)
Estoxx <- indices[,1] #see if price index
Estoxx <- na.omit(Estoxx)
R <- diff(Estoxx, log = TRUE, na.pad = FALSE)*100
R <- na.omit(R) 
```

```{r loadenv, echo=F}
# load("myEnvironment.RData")
load("envplusacd.RData")
source("scripts_and_filters/Custom_Functions.R")
```

### MLE distribution parameters

```{r mlesgt, echo=FALSE, eval=FALSE}
require(sgt)
require(graphics)
require(stats)

```

```{r MLEtables for different series, include=FALSE,eval=FALSE, echo=FALSE}
R_dotcom <- window(R, start = "1987-01-01", end = "2001-12-31")
R_GFC <- window(R, start = "2002-01-01", end = "2009-03-31")
R_covid <- window(R, start = "2009-03-31")
#length(R_dotcom); length(R_GFC); length(R_covid)

MLE_Full <- DistMLE(R)
MLE_dotcom <- DistMLE(R_dotcom)
MLE_GFC <- DistMLE(R_GFC)
MLE_covid <- DistMLE(R_covid)
```

In table \@ref(tab:MLEtable) we can see the estimated parameters of the unconditional distribution functions. Note that the student-t and skewed student-t distribution are usually noted with degrees of freedom as parameters. For consistency, we have parameterized them using limiting cases of the SGT-distribution. Note that to read the degrees of freedom for the two distributions, it is simply $2\eta$. They are presented for the Skewed Generalized T-distribution (SGT) and limiting cases thereof previously discussed. Additionally, maximum likelihood score and the Akaike Information Criterion (AIC) is reported to compare goodness of fit of the different distributions but also taking into account simplicity of the models. We find that the SGT-distribution has the highest maximum likelihood score of all. All other distributions have relatively similar likelihood scores, though slightly lower and are therefore not the optimal distributions. However, when considering AIC it is a tie between SGT and SGED. This provides some indication that we have a valid case to test the suitability of different SGED-GARCH VaR models as an alternative for the SGT-GARCH VaR models. While sacrificing some goodness of fit, the SGED distribution has the advantage of requiring one parameter less, which could possibly result in less errors due to misspecification and easier implementation. For the SGT parameters the standard deviation and skewness are both significant at the 1% level. For the SGED parameters, the standard deviation and the skewness are both significant at respectively the 1% and 5% level. Both distributions are right-skewed. For both distributions the shape parameters are significant at the 1% level, though the $q$ parameter was not estimated as it is by design set to infinity due to the SGED being a limiting case of SGT.[^findings-1]  \

[^findings-1]: To check whether the relative ranking of distributions still holds in different periods, we have calculated the maximum likelihood score and AIC for three smaller periods: The period up to the dotcom collapse (1987-2001), up to the GFC (2002-2009) and up to the present Covid-crash (2009-2021). There is no qualitative difference in relative ranking with these subsamples. Results are reported in the appendix.

\noindent Additionally, for every distribution fitted with MLE, plots are generated to compare the theoretical distribution with the observed returns. We see that except for the normal distribution which is quite off, the theoretical distributions are close to the actual data, except that they are too peaked. This problem is the least present for the SGT distribution.

```{r table2prep, include=FALSE, eval=FALSE}
# par(mfrow = c(3,2), mar = c(1,4,3,3))
Eurostoxx <- DistMLE(R)
table2 <- Eurostoxx$table
table2[table2 == "(NA)"] <- NA
colnames(table2) <- c("", "$\\alpha$","$\\beta$","$\\xi$","$\\kappa$","$\\eta$","$LLH$","AIC")
# table2 <-  data.frame(table2, check.names = F, fix.empty.names = FALSE)
writexl::write_xlsx(table2,"findings/table2.xlsx")
```

```{r importtable2, eval=F}
table2 <- read_excel("findings/table2.xlsx")
colnames(table2) <- c("", "$\\alpha$","$\\beta$","$\\xi$","$\\kappa$","$\\eta$","$LLH$","AIC")
```

```{r table2final,echo=FALSE, results='asis'}
tablenames <- c("SGT","","SGED","","GED","","ST","","T","","N","")
kbl(table2,col.names= c("$dist$", "$\\alpha$","$\\beta$","$\\xi$","$\\kappa$","$\\eta$","$LLH$","AIC") ,caption = "Maximum likelihood estimates of unconditional distribution functions",
      label = 'MLEtable',format="latex",
      booktabs = T,
      position = "h!",
      digits = 3,
    escape=F
      )%>%
  kable_classic(full_width = F)%>%
  footnote(general = "Table contains parameter estimates for SGT-distribution and some of its limiting cases. The underlying data is the daily return series of the Euro Stoxx 50 for the period between December 31. 1986 and April 27. 2021. Standard errors are reported between brackets. $LLH$ is the maximum log-likelihood value. *, ** and *** point out significance at 10, 5 and 1 percent level.",threeparttable = T,footnote_as_chunk = F, escape=F, general_title = "Notes:") %>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

\newpage
## Constant higher moments

```{r garchcode, eval=FALSE}
# we need this code for the roll, figures etc.
distributions <- c("norm", "std", "sstd", "ged", "sged")
Models.garch <- c("sGARCH","eGARCH","fGARCH.AVGARCH","fGARCH.NAGARCH", "gjrGARCH", "fGARCH.TGARCH", "iGARCH", "EWMA")
Models.garch.clean <-  toupper(gsub("fGARCH.", "", Models.garch)) # we use this for tables

for(i in 1:length(Models.garch)){
assign(paste0("garchspec.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
assign(paste0("garchfit.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
assign(paste0("stdret.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
}


#.sGARCH--------------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.sGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "sGARCH", garchOrder = c(1,1), variance.targeting = F),
                     distribution.model = distributions[i])
# Estimate the model
garchfit.sGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.sGARCH[[i]])
}
#.eGARCH-------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.eGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "eGARCH", variance.targeting = F),
                     distribution.model = distributions[i])
# Estimate the model
garchfit.eGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.eGARCH[[i]])
# Compute stdret using residuals()
}

#.fGARCH.NAGARCH------------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.fGARCH.NAGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "fGARCH", submodel = "NAGARCH", variance.targeting = F),
                     distribution.model = distributions[i])
# Estimate the model
garchfit.fGARCH.NAGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.fGARCH.NAGARCH[[i]])
# Compute stdret using residuals()
}

#.fGARCH.AVGARCH------------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.fGARCH.AVGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "fGARCH", submodel = "AVGARCH", variance.targeting = F),
                     distribution.model = distributions[i])
# Estimate the model
garchfit.fGARCH.AVGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.fGARCH.AVGARCH[[i]])
# Compute stdret using residuals()
}

#.gjrGARCH------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.gjrGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "gjrGARCH", variance.targeting = F),
                     distribution.model = distributions[i])
# Estimate the model
garchfit.gjrGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.gjrGARCH[[i]])
# Compute stdret using residuals()
}

#fGARCH.TGARCH-------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.fGARCH.TGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "fGARCH", submodel = "TGARCH", variance.targeting = F),
                     distribution.model = distributions[i])
# Estimate the model
garchfit.fGARCH.TGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.fGARCH.TGARCH[[i]])
# Compute stdret using residuals()
}

#.iGARCH--------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.iGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "iGARCH", variance.targeting = F),
                     distribution.model = distributions[i])
# Estimate the model
garchfit.iGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.iGARCH[[i]])
# Compute stdret using residuals()
}

#.EWMA-----------------
# we need EWMA
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.EWMA[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "iGARCH", variance.targeting = F),
                     distribution.model = distributions[i], fixed.pars = list(omega=0))
# Estimate the model
garchfit.EWMA[[i]] <- ugarchfit(data = R, spec = garchspec.EWMA[[i]])
# Compute stdret using residuals()
}
```

```{r table3prep, echo=FALSE}

#PARTIAL RESULTS

Table.3.iGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.iGARCH)
Table.3.eGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.eGARCH)
Table.3.gjrGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.gjrGARCH)
Table.3.sGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.sGARCH)
Table.3.EWMA <- Table.GARCH.function(GARCHfit.object = garchfit.EWMA)
Table.3.fGARCH.AVGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.fGARCH.AVGARCH)
Table.3.fGARCH.NAGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.fGARCH.NAGARCH)
Table.3.fGARCH.TGARCH <- Table.GARCH.function(GARCHfit.object = garchfit.fGARCH.TGARCH)

Table.3 <- vector(mode = "list", length = length(distributions))
names(Table.3) <- c("Norm", "T", "ST", "GED", "SGED")
for(i in 1:length(distributions)){
  Table.3[[i]] <- suppressMessages(Table.3.function(distribution = distributions[i]))
}
Table.3$ST[15,-1] <- as.numeric(Table.3$ST[15,-1])/2
patterns <- str_count(Table.3$ST[16,-1], "\\*")
numbers <- tidyr::extract_numeric(Table.3$ST[16,-1])/2
for (i in 1:length(patterns)){
   Table.3$ST[16,i+1] <- paste0("(", numbers[i], ")", paste(rep("*",patterns[i]),collapse = ""))
} 

fn1.3 <- sprintf(paste0('This table shows the maximum likelihood estimates of various ST-GARCH models. The daily returns used on the ',stringr::str_to_title(gsub(pattern = '\\.', replacement=' ',colnames(R)))," cover the period from ",gsub(" UTC", "",format(min(index(R)), '%d %B, %Y'))," to ",gsub(" UTC", "",format(max(index(R)),'%d %B, %Y')), " (", nrow(R)," observations)."))
fn2.3 <- sprintf("The mean process is modeled as follows: $R_t= \\\\alpha_0+ \\\\alpha_1 \\\\times R_{t-1}+ \\\\varepsilon_t$ Where, in the %s GARCH models estimated, $\\\\gamma$ is the asymmetry in volatility, $\\\\xi, \\\\kappa$ and $\\\\eta$ are constant and robust standard errors based on the method of White (1982)) are displayed in parenthesis. $LLH$ is the maximized log likelihood value.", ncol(Table.3$ST)-1)
```

\noindent Table \@ref(tab:Table3) presents the maximum likelihood estimates for `r ncol(Table.3$ST)-1` GARCH models based on the ST distribution with constant skewness and kurtosis parameters (robust white errors are presented in parenthesis). The parameter $\alpha_0$ are only statistically significant for the SGARCH, IGARCH and EWMA model with a value close to 0. The AR(1) coefficient, $\alpha_1$, has parameters going from `r min(as.numeric(Table.3$ST[3,-1]))` to `r max(as.numeric(Table.3$ST[3,-1]))` with $p$ values ranging from `r min(as.numeric(str_remove_all(Table.3$ST[4,-1], "[()*]")))` to `r max(as.numeric(stringr::str_remove_all(Table.3$ST[4,-1], "[()*]")))` suggesting significance, but indicating very small negative autocorrelation. The GARCH parameters in the conditional variance equations ($\beta_0$) are generally statistically significant except for the EGARCH model. The results of $\beta_1$ and $\beta_2$ show the presence of significant time-variation in the conditional volatility of the Euro Stoxx 50, in fact, the sum of $\beta_1$ and $\beta_2$ for the GARCH parameters is close to one (from `r min(as.numeric(str_remove_all(as.numeric(Table.3$ST[7,-1])+as.numeric(Table.3$ST[9,-1]), "[()]")), na.rm = TRUE)` to `r max(as.numeric(str_remove_all(as.numeric(Table.3$ST[7,-1])+as.numeric(Table.3$ST[9,-1]), "[()]")), na.rm = TRUE)`), suggesting the presence of persistence in the volatility of the returns. The parameter $\xi$ is highly significant for all the `r ncol(Table.3$ST)-1` models tested with values ranging from `r min(as.numeric(str_remove_all(Table.3$ST[11,-1], "[()]")), na.rm = TRUE)` to `r max(as.numeric(str_remove_all(Table.3$ST[11,-1], "[()]")), na.rm = TRUE)` confirming the presence of skewness in the returns. The shape parameter $\eta$, which, in our case, measures the number of degrees of freedom divided by two, determining the tail behavior, is significant for all the models and ranges between `r min(as.numeric(str_remove_all(Table.3$ST[15,-1], "[()]")), na.rm = TRUE)` and `r max(as.numeric(str_remove_all(Table.3$ST[15,-1], "[()]")), na.rm = TRUE)`. The parameter $\gamma$, which is present only for EGARCH and GJRGARCH is significant and with values around `r round(mean(as.numeric(str_remove_all(Table.3$ST[17,-1], "[()]")), na.rm = TRUE),2)`. The absolute value function in family GARCH models (NAGARCH, TGARCH and AVGARCH) is subject to the $shift$ and the $rot$ parameters whose values are always positive and statistically significant. According to the log likelihood values ($LLH$), displayed in table \@ref(tab:Table3), the model with the highest value is `r toupper(colnames(Table.3$ST[,-1])[which.max(as.numeric(str_remove_all(Table.3$ST[23,-1], "[()]")))])` while, excluding the non-standard GARCH models from the analysis, the model that performs best is `r toupper(colnames(Table.3$ST[,-c(1,7,8,9)])[which.max(as.numeric(str_remove_all(Table.3$ST[23,-c(1,7,8,9)], "[()]")))])`. \

\noindent Table \@ref(tab:Table3b) shows a very similar picture for the GARCH-SGED models as the GARCH-ST models. 

```{r table3final, echo=F, results='asis'}
kbl(Table.3$ST[-c(13,14),], col.names = toupper(colnames(Table.3$ST)),caption = "Maximum likelihood estimates of the ST-GARCH models with constant skewness and kurtosis parameters",#format="latex",
      label = 'Table3',
      booktabs = T, row.names = F, escape = F )%>%
  kable_classic(full_width = F)%>%
  footnote(general = c(fn1.3,fn2.3),threeparttable = T,footnote_as_chunk = F, escape=F, general_title = "Notes:")%>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

```{=tex}
\clearpage
\newpage
```
```{r table3bfinal, echo=F, results='asis'}
fn1.3b <- sprintf(paste0('This table shows the maximum likelihood estimates of various SGED-GARCH models. The daily returns used on the ',stringr::str_to_title(gsub(pattern = '\\.', replacement=' ',colnames(R)))," Price index cover the period from ",gsub(" UTC", "",format(min(index(R)), '%d %B, %Y'))," to ",gsub(" UTC", "",format(max(index(R)),'%d %B, %Y')), " (", nrow(R)," observations)."))
fn2.3 <- sprintf("The mean process is modeled as follows: $R_t= \\\\alpha_0+ \\\\alpha_1 \\\\times R_{t-1}+ \\\\varepsilon_t$ Where, in the %s GARCH models estimated, $\\\\gamma$ is the asymmetry in volatility, $\\\\xi, \\\\kappa$ and $\\\\eta$ are constant and robust standard errors based on the method of White (1982)) are displayed in parenthesis. $LLH$ is the maximized log likelihood value.", ncol(Table.3$ST)-1)
kbl(Table.3$SGED[-c(13,14),], col.names = toupper(colnames(Table.3$SGED)),caption = "Maximum likelihood estimates of the SGED-GARCH models with constant skewness and kurtosis parameters",format = "latex",
      label = 'Table3b',
      booktabs = T, row.names = F, escape = F )%>%
  kable_classic(full_width = F)%>%
  footnote(general = c(fn1.3b,fn2.3),threeparttable = T,footnote_as_chunk = F, escape=F, general_title = "Notes:")%>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

```{=tex}
\clearpage
\newpage
```
\noindent To compare the goodness-of-fit of different combinations of GARCH models and distributions, we have portrayed the AICs in table \@ref(tab:aicTable). The smaller the criterium the better. As you can see in table \@ref(tab:aicTable) the AIC for the skewed student's t-distribution (ST) is the best for almost all the models. As also shown in appendix part \@ref(goodness-of-fit). Only for the SGARCH and IGARCH the SGED distribution has a lower AIC. The best goodness-of-fit over all distributions seems to be the NAGARCH model.

\noindent  Due to \@ref(tab:aicTable) being the result of an in-sample estimation, we will further examine the performance five different GARCH models (EGARCH, GJRGARCH, NAGARCH, AVGARCH and TGARCH).

```{r aictableprep, eval=F}
aic_sGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_sGARCH[i] = infocriteria(garchfit.sGARCH[[i]])[1]
}

aic_iGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_iGARCH[i] = infocriteria(garchfit.iGARCH[[i]])[1]
}

aic_EWMA <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_EWMA[i] = infocriteria(garchfit.EWMA[[i]])[1]
}

aic_eGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_eGARCH[i] = infocriteria(garchfit.eGARCH[[i]])[1]
}

aic_gjrGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_gjrGARCH[i] = infocriteria(garchfit.gjrGARCH[[i]])[1]
}

aic_naGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_naGARCH[i] = infocriteria(garchfit.fGARCH.NAGARCH[[i]])[1]
}

aic_tGARCH <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_tGARCH[i] = infocriteria(garchfit.fGARCH.TGARCH[[i]])[1]
}

aic_avgarch <- vector(length=length(distributions))
for (i in 1:length(distributions)) {
  aic_avgarch[i] = infocriteria(garchfit.fGARCH.AVGARCH[[i]])[1]
}

aics <- matrix(ncol=length(Models.garch), nrow = length(distributions))
rownames(aics) <- c("N", "T", "ST", "GED", "SGED")
colnames(aics) <- Models.garch.clean[c(1,7,8,2,5,4,6,3)]
aics[,1] <- aic_sGARCH
aics[,2] <- aic_iGARCH
aics[,3] <- aic_EWMA
aics[,4] <- aic_eGARCH
aics[,5] <- aic_gjrGARCH
aics[,6] <- aic_naGARCH
aics[,7] <- aic_tGARCH
aics[,8] <- aic_avgarch

tableAIC <- as.data.frame(round(aics,4))
tableAIC <- rbind(tableAIC[5,], tableAIC[4,], tableAIC[3,], tableAIC[2,],tableAIC[1,])



# for ourselves: quick conditional formatting
#require(condformat)
# cf <-  condformat(tableAIC) %>%
#   rule_fill_discrete(SGARCH,expression =SGARCH==min(SGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(IGARCH,expression =IGARCH==min(IGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(EWMA,expression =EWMA==min(EWMA), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(EGARCH,expression =EGARCH==min(EGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(GJRGARCH,expression =GJRGARCH==min(GJRGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(NAGARCH,expression =NAGARCH==min(NAGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen"))  %>%
#   rule_fill_discrete(TGARCH,expression =TGARCH==min(TGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen")) %>%
#   rule_fill_discrete(AVGARCH,expression =AVGARCH==min(AVGARCH), colours = c("FALSE" = "white", "TRUE" = "lightgreen"))
```

```{r aictablelatex, echo=F, results='asis'}
aics %>% kbl(caption = "Model selection according to AIC",
      label = 'aicTable',format="latex",
      booktabs = T,
      position = "h!",
      digits = 3 )%>%
  kable_classic(full_width = F)%>%
  footnote(general_title= "Notes",general="This table shows the AIC value for the respective model. With on the rows the distributions. ",threeparttable = T,footnote_as_chunk = F, escape=F) %>%
  kable_styling(latex_options = "scale_down") 
```



```{=tex}
\clearpage
\newpage
```
### Value-at-risk

\noindent As already mentioned 2 candidate models seem to be very appropriate. This includes the EGARCH and the NAGARCH So to check if they perform well out-of-sample we conduct a backtest by using a rolling forecasting technique. A simple graph is shown in figure \@ref(fig:figVaRinsample) for the EGARCH-ST model. It seems that the VaR model for $\alpha=0.05$ underestimates the downside events, while the VaR model for $\alpha=0.01$ captures more of the downside events.

```{r figVaRinsample, fig.cap="Value-at-Risk (in-sample) for the EGARCH-ST model", fig.align='center', fig.pos = 'h', out.width='60%', echo=FALSE}
par(mfrow = c(2,1))
par(mar = c(2.1, 3.1, 1.1, 3.1))
Conditional.variance <- sigma(garchfit.eGARCH[[3]])
Conditional.mean <- fitted(garchfit.eGARCH[[3]])
n <- garchfit.eGARCH[[3]]@fit$coef["shape"]
VaR05 <- as.numeric(Conditional.mean + Conditional.variance*qdist("sstd",p=0.05,
shape = coef(garchfit.eGARCH[[3]])["shape"],skew  = coef(garchfit.eGARCH[[3]])["skew"]))
plot(as.matrix(R), type = "l" , xlab = "" ,
ylab = "95% VaR value", col = "darkgray"); lines(VaR05,col = adjustcolor("red",alpha.f=0.5)); legend ("topleft", bty = "n", lty = c (1,1) , col = c("darkgrey", adjustcolor("red" ,alpha.f =0.5)) ,legend = c(expression(R[t]), expression(VaR[0.05][","][t])))

VaR01 <- as.numeric(Conditional.mean + Conditional.variance*qdist("sstd",p=0.01,
shape = coef(garchfit.eGARCH[[3]])["shape"],skew  = coef(garchfit.eGARCH[[3]])["skew"]))
plot(as.matrix(R), type = "l" , xlab = "T" ,
ylab = "99% VaR value", col = "darkgray"); lines(VaR01, col = adjustcolor("green",alpha.f=0.5)); legend ("topleft", bty = "n", lty = c (1,1) , col = c("darkgrey", adjustcolor("green" ,alpha.f =0.5)) ,legend = c(expression(R[t]), expression(VaR[0.01][","][t])))
```

\noindent Let us examine this further using a rolling window approach whilst forecasting 1-day ahead results with re-estimating parameters every year.

\noindent Figure \@ref(fig:figbacktest) shows that choosing an appropriate forecast period is important (with here the Eurobond crisis, the Brexit and Covid-crisis), so in order to avoid a look-ahead bias this rolling window approach was used instead of a static forecast method. \newpage

```{r figbacktest, fig.cap = "Selected period to start forecast from",out.width='70%', fig.align='center',fig.pos='h', echo=FALSE}
par(mfrow = c(1,1), mar = c(2, 2, 2, 2))
xtsExtra::plot.xts(na.omit(Estoxx), col = 'steelblue', screens = 1, blocks = list(start.time = paste(head(tail(index(Estoxx),2500), 1)), end.time = paste(index(tail(Estoxx, 1))), col = 'grey90'), main = 'Euro Stoxx 50', minor.ticks = FALSE)
```

```{r garchroll, eval = FALSE}
# VaR garchroll forecasting and backtesting----
# x = garchspec.eGARCH[[i]]

# Enjo Timing = first hash
```

```{r garchrollegarch, eval = FALSE}
egarch.normback <- roll(garchspec.eGARCH[[1]]) #37.66 sec
egarch.stdback <- roll(garchspec.eGARCH[[2]])  #1,3min 
egarch.sstdback <- roll(garchspec.eGARCH[[3]]) #1.5min
egarch.gedback <- roll(garchspec.eGARCH[[4]])  #1.1min
egarch.sgedback <- roll(garchspec.eGARCH[[5]]) #2min 
```

```{r garchrollgjrgarch, eval = FALSE}
gjrgarch.normback <- roll(garchspec.gjrGARCH[[1]]) #14.23 sec
gjrgarch.stdback <- roll(garchspec.gjrGARCH[[2]])  #19.36 sec
gjrgarch.sstdback <- roll(garchspec.gjrGARCH[[3]]) #24.75 sec
gjrgarch.gedback <- roll(garchspec.gjrGARCH[[4]])  #21.13 sec
gjrgarch.sgedback <- roll(garchspec.gjrGARCH[[5]]) #30.24 sec
```

```{r garchrollnagarch, eval = FALSE}
nagarch.normback <- roll(garchspec.fGARCH.NAGARCH[[1]]) #14.88 sec
nagarch.stdback <- roll(garchspec.fGARCH.NAGARCH[[2]])  #20.31 sec
nagarch.sstdback <- roll(garchspec.fGARCH.NAGARCH[[3]]) #27.25 sec
nagarch.gedback <- roll(garchspec.fGARCH.NAGARCH[[4]])  #22.39 sec
nagarch.sgedback <- roll(garchspec.fGARCH.NAGARCH[[5]]) #34.98 sec
```

```{r garchrolltgarch, eval = FALSE}
tgarch.normback <- roll(garchspec.fGARCH.TGARCH[[1]]) #15.48 sec
tgarch.stdback <- roll(garchspec.fGARCH.TGARCH[[2]])  #19.32 sec
tgarch.sstdback <- roll(garchspec.fGARCH.TGARCH[[3]]) #26.27 sec
tgarch.gedback <- roll(garchspec.fGARCH.TGARCH[[4]])  #20.26 sec
tgarch.sgedback <- roll(garchspec.fGARCH.TGARCH[[5]]) #29.29 sec
```

```{r garchrollavgarch, eval = FALSE}
avgarch.normback <- roll(garchspec.fGARCH.AVGARCH[[1]]) #20.65 sec
avgarch.stdback <- roll(garchspec.fGARCH.AVGARCH[[2]])  #35.63 sec
avgarch.sstdback <- roll(garchspec.fGARCH.AVGARCH[[3]]) #52.54 sec
avgarch.gedback <- roll(garchspec.fGARCH.AVGARCH[[4]])  #42.59 sec
avgarch.sgedback <- roll(garchspec.fGARCH.AVGARCH[[5]]) #1.03 min
# q1 = q5 = px = matrix(NA, ncol = 1, nrow = 6453)
# q1[, 1] = as.numeric(apply(egarch.normback@forecast$density, 1, function(x) qdist("norm", 0.01, mu = x['Mu'], sigma = x['Sigma'], skew = x['Skew'], shape = x['Shape'])))
# q5[, 1] = as.numeric(apply(egarch.normback@forecast$density, 1, function(x) qdist("norm", 0.05, mu = x['Mu'], sigma = x['Sigma'], skew = x['Skew'], shape = x['Shape'])))
# VaR1cc1 = apply(q1, 2, function(x) VaRTest(0.01, actual = egarch.normback@forecast$VaR[, 'realized'], VaR = x))
# VaR5cc1 = apply(q5, 2, function(x) VaRTest(0.05, actual = egarch.normback@forecast$VaR[, 'realized'], VaR = x))
```

```{r backup, echo=FALSE, eval=FALSE}
#save.image(file='myEnvironment.RData')
```

\noindent If we look at the results of the rolling window, we can for example compare as in figure \@ref(fig:figurebacktests2) the EGARCH-ST (with skewed student's t-distribution) with the EGARCH-N (with normal distribution). The EGARCH-N seems to capture the extreme events a bit less compared EGARCH-ST. But let us formally test this. \

\newpage

```{r figurebacktests2,fig.cap = "Comparison between VaR-EGARCH-ST and VaR-NAGARCH-N", fig.align='center', fig.pos='h',echo=FALSE, echo=FALSE, out.width="90%"}
# EGARCH with sstd vs NAGARCH with sstd
par(mfrow = c(2,1), mar = c(2.5,2.5,1.5,2.5))
# EGARCH with SSTD
plot(egarch.sstdback,which=4,VaR.alpha=0.01)
legend("topright",bty="n",legend= bquote(~ alpha == "0.01"))
title(main = "EGARCH-ST")
# NAGARCH with SSTD
plot(egarch.normback,which=4,Var.alpha=0.01)
legend("topright",bty="n",legend= bquote(~ alpha == "0.01"))
title(main = "EGARCH-N")
```

```{r gaspackagetests, include=F, echo=F}
require(GAS)

VaR.norm.egarch <- getVaR(egarch.normback)
VaR.std.egarch <- getVaR(egarch.stdback)
VaR.ged.egarch <- getVaR(egarch.gedback)
VaR.sstd.egarch <- getVaR(egarch.sstdback)
VaR.sged.egarch <- getVaR(egarch.sgedback)
 
VaR.norm.gjrgarch <- getVaR(gjrgarch.normback)
VaR.std.gjrgarch <- getVaR(gjrgarch.stdback)
VaR.ged.gjrgarch <- getVaR(gjrgarch.gedback)
VaR.sstd.gjrgarch <- getVaR(gjrgarch.sstdback)
VaR.sged.gjrgarch <- getVaR(gjrgarch.sgedback)

VaR.norm.tgarch <- getVaR(tgarch.normback)
VaR.std.tgarch <- getVaR(tgarch.stdback)
VaR.ged.tgarch <- getVaR(tgarch.gedback)
VaR.sstd.tgarch <- getVaR(tgarch.sstdback)
VaR.sged.tgarch <- getVaR(tgarch.sgedback)

VaR.norm.nagarch <- getVaR(nagarch.normback)
VaR.std.nagarch <- getVaR(nagarch.stdback)
VaR.ged.nagarch <- getVaR(nagarch.gedback)
VaR.sstd.nagarch <- getVaR(nagarch.sstdback)
VaR.sged.nagarch <- getVaR(nagarch.sgedback)

VaR.norm.avgarch <- getVaR(avgarch.normback)
VaR.std.avgarch <- getVaR(avgarch.stdback)
VaR.ged.avgarch <- getVaR(avgarch.gedback)
VaR.sstd.avgarch <- getVaR(avgarch.sstdback)
VaR.sged.avgarch <- getVaR(avgarch.sgedback)

```

```{r ES_Test, eval=F}

#ES for egarch

e_sged_ES <- ESTesting(egarch.sgedback, VaR.sged.egarch, "sged")
e_sged_AE_ES <- e_sged_ES[2]
e_sged_AE_p <- e_sged_ES[[3]] 

e_ged_ES <- ESTesting(egarch.gedback, VaR.ged.egarch, "ged")
e_ged_AE_ES <- e_ged_ES[2]
e_ged_AE_p <- e_ged_ES[[3]] 

e_sstd_ES <- ESTesting(egarch.sstdback, VaR.sstd.egarch, "sstd")
e_sstd_AE_ES <- e_sstd_ES[2]
e_sstd_AE_p <- e_sstd_ES[[3]] 

e_std_ES <- ESTesting(egarch.sstdback, VaR.std.egarch, "std")
e_std_AE_ES <- e_std_ES[2]
e_std_AE_p <- e_std_ES[[3]] 

e_norm_ES <- ESTesting(egarch.normback, VaR.norm.egarch, "norm")
e_norm_AE_ES <- e_norm_ES[2]
e_norm_AE_p <- e_norm_ES[[3]]

#ES for gjrgarch

gjr_sged_ES <- ESTesting(gjrgarch.sgedback, VaR.sged.gjrgarch,"sged")
gjr_sged_AE_ES <- gjr_sged_ES[2]
gjr_sged_AE_p <- gjr_sged_ES[[3]] 

gjr_ged_ES <- ESTesting(gjrgarch.gedback, VaR.ged.gjrgarch,"ged")
gjr_ged_AE_ES <- gjr_ged_ES[2]
gjr_ged_AE_p <- gjr_ged_ES[[3]] 

gjr_sstd_ES <- ESTesting(gjrgarch.sstdback, VaR.sstd.gjrgarch,"sstd")
gjr_sstd_AE_ES <- gjr_sstd_ES[2]
gjr_sstd_AE_p <- gjr_sstd_ES[[3]] 

gjr_std_ES <- ESTesting(gjrgarch.sstdback,VaR.std.gjrgarch, "std")
gjr_std_AE_ES <- gjr_std_ES[2]
gjr_std_AE_p <- gjr_std_ES[[3]] 

gjr_norm_ES <- ESTesting(gjrgarch.normback, VaR.norm.gjrgarch,"norm")
gjr_norm_AE_ES <- gjr_norm_ES[2]
gjr_norm_AE_p <- gjr_norm_ES[[3]]

#ES for tgarch

t_sged_ES <- ESTesting(tgarch.sgedback, VaR.sged.tgarch,"sged")
t_sged_AE_ES <- t_sged_ES[2]
t_sged_AE_p <- t_sged_ES[[3]] 

t_ged_ES <- ESTesting(tgarch.gedback, VaR.ged.tgarch,"ged")
t_ged_AE_ES <- t_ged_ES[2]
t_ged_AE_p <- t_ged_ES[[3]] 

t_sstd_ES <- ESTesting(tgarch.sstdback, VaR.sstd.tgarch,"sstd")
t_sstd_AE_ES <- t_sstd_ES[2]
t_sstd_AE_p <- t_sstd_ES[[3]] 

t_std_ES <- ESTesting(tgarch.sstdback, VaR.std.tgarch,"std")
t_std_AE_ES <- t_std_ES[2]
t_std_AE_p <- t_std_ES[[3]] 

t_norm_ES <- ESTesting(tgarch.normback, VaR.norm.tgarch,"norm")
t_norm_AE_ES <- t_norm_ES[2]
t_norm_AE_p <- t_norm_ES[[3]]

#ES for nagarch

na_sged_ES <- ESTesting(nagarch.sgedback, VaR.sged.nagarch,"sged")
na_sged_AE_ES <- na_sged_ES[2]
na_sged_AE_p <- na_sged_ES[[3]] 

na_ged_ES <- ESTesting(nagarch.gedback, VaR.ged.nagarch,"ged")
na_ged_AE_ES <- na_ged_ES[2]
na_ged_AE_p <- na_ged_ES[[3]] 

na_sstd_ES <- ESTesting(nagarch.sstdback, VaR.sstd.nagarch,"sstd")
na_sstd_AE_ES <- na_sstd_ES[2]
na_sstd_AE_p <- na_sstd_ES[[3]] 

na_std_ES <- ESTesting(nagarch.sstdback, VaR.std.nagarch,"std")
na_std_AE_ES <- na_std_ES[2]
na_std_AE_p <- na_std_ES[[3]] 

na_norm_ES <- ESTesting(nagarch.normback, VaR.norm.nagarch,"norm")
na_norm_AE_ES <- na_norm_ES[2]
na_norm_AE_p <- na_norm_ES[[3]]

#ES for avgarch

av_sged_ES <- ESTesting(avgarch.sgedback, VaR.sged.avgarch,"sged")
av_sged_AE_ES <- av_sged_ES[2]
av_sged_AE_p <- av_sged_ES[[3]] 

av_ged_ES <- ESTesting(avgarch.gedback, VaR.ged.avgarch,"ged")
av_ged_AE_ES <- av_ged_ES[2]
av_ged_AE_p <- av_ged_ES[[3]] 

av_sstd_ES <- ESTesting(avgarch.sstdback, VaR.sstd.avgarch,"sstd")
av_sstd_AE_ES <- av_sstd_ES[2]
av_sstd_AE_p <- av_sstd_ES[[3]] 

av_std_ES <- ESTesting(avgarch.sstdback, VaR.std.avgarch,"std")
av_std_AE_ES <- av_std_ES[2]
av_std_AE_p <- av_std_ES[[3]] 

av_norm_ES <- ESTesting(avgarch.normback, VaR.norm.avgarch,"norm")
av_norm_AE_ES <- av_norm_ES[2]
av_norm_AE_p <- av_norm_ES[[3]]
```

```{r table4prep, echo=F}

e_sged <- gettests(VaR.sged.egarch)
e_ged <- gettests(VaR.ged.egarch)
e_sstd <- gettests(VaR.sstd.egarch)
e_std <- gettests(VaR.std.egarch)
e_norm <- gettests(VaR.norm.egarch)

gjr_sged <- gettests(VaR.sged.gjrgarch)
gjr_ged <- gettests(VaR.ged.gjrgarch)
gjr_sstd <- gettests(VaR.sstd.gjrgarch)
gjr_std <- gettests(VaR.std.gjrgarch)
gjr_norm <- gettests(VaR.norm.gjrgarch)

t_sged <- gettests(VaR.sged.tgarch)
t_ged <- gettests(VaR.ged.tgarch)
t_sstd <- gettests(VaR.sstd.tgarch)
t_std <- gettests(VaR.std.tgarch)
t_norm <- gettests(VaR.norm.tgarch)

na_sged <- gettests(VaR.sged.nagarch)
na_ged <- gettests(VaR.ged.nagarch)
na_sstd <- gettests(VaR.sstd.nagarch)
na_std <- gettests(VaR.std.nagarch)
na_norm <- gettests(VaR.norm.nagarch)

av_sged <- gettests(VaR.sged.avgarch)
av_ged <- gettests(VaR.ged.avgarch)
av_sstd <- gettests(VaR.sstd.avgarch)
av_std <- gettests(VaR.std.avgarch)
av_norm <- gettests(VaR.norm.avgarch)

#TABLE LAYOUT 

table_tests <- matrix(nrow=30,ncol=5)
rownames(table_tests) <- c("SGED","AE_var","AE_ES", "UC","CC","DQ","GED","AE_var","AE_ES","UC","CC","DQ","ST","AE_var","AE_ES","UC","CC","DQ","T","AE_var","AE_ES","UC","CC","DQ","Norm","AE_var","AE_ES","UC","CC","DQ")
colnames(table_tests) <- c("eGarch","gjrGarch","tGarch","naGarch","avGarch")
table_tests <- as.data.frame(table_tests)
#STATISTICS

table_tests[2,] <- c(e_sged$ae, gjr_sged$ae,t_sged$ae,na_sged$ae,av_sged$ae)
table_tests[3,] <- c(as.numeric(e_sged_AE_ES), as.numeric(gjr_sged_AE_ES), as.numeric(t_sged_AE_ES), as.numeric(na_sged_AE_ES), as.numeric(av_sged_AE_ES))
table_tests[4,] <- c(e_sged$uc[1], gjr_sged$uc[1],t_sged$uc[1],na_sged$uc[1],av_sged$uc[1])
table_tests[5,] <- c(e_sged$cc[1], gjr_sged$cc[1],t_sged$cc[1],na_sged$cc[1],av_sged$cc[1])
table_tests[6,] <- c(e_sged$dq$stat, gjr_sged$dq$stat,t_sged$dq$stat,na_sged$dq$stat,av_sged$dq$stat)
table_tests[8,]<- c(e_ged$ae, gjr_ged$ae,t_ged$ae,na_ged$ae,av_ged$ae)
table_tests[9,] <- c(as.numeric(e_ged_AE_ES), as.numeric(gjr_ged_AE_ES), as.numeric(t_ged_AE_ES), as.numeric(na_ged_AE_ES), as.numeric(av_ged_AE_ES))
table_tests[10,]<- c(e_ged$uc[1], gjr_ged$uc[1],t_ged$uc[1],na_ged$uc[1],av_ged$uc[1])
table_tests[11,]<- c(e_ged$cc[1], gjr_ged$cc[1],t_ged$cc[1],na_ged$cc[1],av_ged$cc[1])
table_tests[12,]<- c(e_ged$dq$stat, gjr_ged$dq$stat,t_ged$dq$stat,na_ged$dq$stat,av_ged$dq$stat)
table_tests[14,]<- c(e_sstd$ae, gjr_sstd$ae,t_sstd$ae,na_sstd$ae,av_sstd$ae)
table_tests[15,] <- c(as.numeric(e_sstd_AE_ES), as.numeric(gjr_sstd_AE_ES), as.numeric(t_sstd_AE_ES), as.numeric(na_sstd_AE_ES), as.numeric(av_sstd_AE_ES))
table_tests[16,]<- c(e_sstd$uc[1], gjr_sstd$uc[1],t_sstd$uc[1],na_sstd$uc[1],av_sstd$uc[1])
table_tests[17,]<- c(e_sstd$cc[1], gjr_sstd$cc[1],t_sstd$cc[1],na_sstd$cc[1],av_sstd$cc[1])
table_tests[18,]<- c(e_sstd$dq$stat, gjr_sstd$dq$stat,t_sstd$dq$stat,na_sstd$dq$stat,av_sstd$dq$stat)
table_tests[20,]<- c(e_std$ae, gjr_std$ae,t_std$ae,na_std$ae,av_std$ae)
table_tests[21,] <- c(as.numeric(e_std_AE_ES), as.numeric(gjr_std_AE_ES), as.numeric(t_std_AE_ES), as.numeric(na_std_AE_ES), as.numeric(av_std_AE_ES))
table_tests[22,]<- c(e_std$uc[1], gjr_std$uc[1],t_std$uc[1],na_std$uc[1],av_std$uc[1])
table_tests[23,]<- c(e_std$cc[1], gjr_std$cc[1],t_std$cc[1],na_std$cc[1],av_std$cc[1])
table_tests[24,]<- c(e_std$dq$stat, gjr_std$dq$stat,t_std$dq$stat,na_std$dq$stat,av_std$dq$stat)
table_tests[26,]<- c(e_norm$ae, gjr_norm$ae,t_norm$ae,na_norm$ae,av_norm$ae)
table_tests[27,] <- c(as.numeric(e_norm_AE_ES), as.numeric(gjr_norm_AE_ES), as.numeric(t_norm_AE_ES), as.numeric(na_norm_AE_ES), as.numeric(av_norm_AE_ES))
table_tests[28,]<- c(e_norm$uc[1], gjr_norm$uc[1],t_norm$uc[1],na_norm$uc[1],av_norm$uc[1])
table_tests[29,]<- c(e_norm$cc[1], gjr_norm$cc[1],t_norm$cc[1],na_norm$cc[1],av_norm$cc[1])
table_tests[30,]<- c(e_norm$dq$stat, gjr_norm$dq$stat,t_norm$dq$stat,na_norm$dq$stat,av_norm$dq$stat)


#PVALUES LOOPS
r3 <- c(ES.signific(e_sged_AE_p),ES.signific(gjr_sged_AE_p),ES.signific(t_sged_AE_p),ES.signific(na_sged_AE_p),ES.signific(av_sged_AE_p))
r4 <- c(uc.signific(e_sged),uc.signific(gjr_sged),uc.signific(t_sged),uc.signific(na_sged),uc.signific(av_sged))
r5 <- c(cc.signific(e_sged),cc.signific(gjr_sged),cc.signific(t_sged),cc.signific(na_sged),cc.signific(av_sged))
r6 <- c(dq.signific(e_sged),dq.signific(gjr_sged),dq.signific(t_sged),dq.signific(na_sged),dq.signific(av_sged))

r9 <- c(ES.signific(e_ged_AE_p),ES.signific(gjr_ged_AE_p),ES.signific(t_ged_AE_p),ES.signific(na_ged_AE_p),ES.signific(av_ged_AE_p))
r10 <- c(uc.signific(e_ged),uc.signific(gjr_ged),uc.signific(t_ged),uc.signific(na_ged),uc.signific(av_ged))
r11 <- c(cc.signific(e_ged),cc.signific(gjr_ged),cc.signific(t_ged),cc.signific(na_ged),cc.signific(av_ged))
r12 <- c(dq.signific(e_ged),dq.signific(gjr_ged),dq.signific(t_ged),dq.signific(na_ged),dq.signific(av_ged))

r15 <- c(ES.signific(e_sstd_AE_p),ES.signific(gjr_sstd_AE_p),ES.signific(t_sstd_AE_p),ES.signific(na_sstd_AE_p),ES.signific(av_sstd_AE_p))
r16 <- c(uc.signific(e_sstd),uc.signific(gjr_sstd),uc.signific(t_sstd),uc.signific(na_sstd),uc.signific(av_sstd))
r17 <- c(cc.signific(e_sstd),cc.signific(gjr_sstd),cc.signific(t_sstd),cc.signific(na_sstd),cc.signific(av_sstd))
r18 <- c(dq.signific(e_sstd),dq.signific(gjr_sstd),dq.signific(t_sstd),dq.signific(na_sstd),dq.signific(av_sstd))

r21 <- c(ES.signific(e_std_AE_p),ES.signific(gjr_std_AE_p),ES.signific(t_std_AE_p),ES.signific(na_std_AE_p),ES.signific(av_std_AE_p))
r22 <- c(uc.signific(e_std),uc.signific(gjr_std),uc.signific(t_std),uc.signific(na_std),uc.signific(av_std))
r23 <- c(cc.signific(e_std),cc.signific(gjr_std),cc.signific(t_std),cc.signific(na_std),cc.signific(av_std))
r24 <- c(dq.signific(e_std),dq.signific(gjr_std),dq.signific(t_std),dq.signific(na_std),dq.signific(av_std))

r27 <- c(ES.signific(e_norm_AE_p),ES.signific(gjr_norm_AE_p),ES.signific(t_norm_AE_p),ES.signific(na_norm_AE_p),ES.signific(av_norm_AE_p))
r28 <- c(uc.signific(e_norm),uc.signific(gjr_norm),uc.signific(t_norm),uc.signific(na_norm),uc.signific(av_norm))
r29 <- c(cc.signific(e_norm),cc.signific(gjr_norm),cc.signific(t_norm),cc.signific(na_norm),cc.signific(av_norm))
r30 <- c(dq.signific(e_norm),dq.signific(gjr_norm),dq.signific(t_norm),dq.signific(na_norm),dq.signific(av_norm))

table_tests[2,] <- paste0(round(table_tests[2,],3),"") #placeholder
table_tests[3,] <- paste0(round(as.numeric(table_tests[3,]),3),r3)
table_tests[4,] <- paste0(round(as.numeric(table_tests[4,]),3),r4)
table_tests[5,] <- paste0(round(as.numeric(table_tests[5,]),3),r5)
table_tests[6,] <- paste0(round(as.numeric(table_tests[6,]),3),r6)
table_tests[8,] <- paste0(round(as.numeric(table_tests[8,]),3),"")
table_tests[9,] <- paste0(round(as.numeric(table_tests[9,]),3),r9)
table_tests[10,] <- paste0(round(as.numeric(table_tests[10,]),3),r10)
table_tests[11,] <- paste0(round(as.numeric(table_tests[11,]),3),r11)
table_tests[12,] <- paste0(round(as.numeric(table_tests[12,]),3),r12)
table_tests[14,] <- paste0(round(as.numeric(table_tests[14,]),3),"")
table_tests[15,] <- paste0(round(as.numeric(table_tests[15,]),3),r15)
table_tests[16,] <- paste0(round(as.numeric(table_tests[16,]),3),r16)
table_tests[17,] <- paste0(round(as.numeric(table_tests[17,]),3),r17)
table_tests[18,] <- paste0(round(as.numeric(table_tests[18,]),3),r18)
table_tests[20,] <- paste0(round(as.numeric(table_tests[20,]),3),"")
table_tests[21,] <- paste0(round(as.numeric(table_tests[21,]),3),r21)
table_tests[22,] <- paste0(round(as.numeric(table_tests[22,]),3),r22)
table_tests[23,] <- paste0(round(as.numeric(table_tests[23,]),3),r23)
table_tests[24,] <- paste0(round(as.numeric(table_tests[24,]),3),r24)
table_tests[26,] <- paste0(round(as.numeric(table_tests[26,]),3),"")
table_tests[27,] <- paste0(round(as.numeric(table_tests[27,]),3),r27)
table_tests[28,] <- paste0(round(as.numeric(table_tests[28,]),3),r28)
table_tests[29,] <- paste0(round(as.numeric(table_tests[29,]),3),r29)
table_tests[30,] <- paste0(round(as.numeric(table_tests[30,]),3),r30)

#KABLE OUTPUT
df <- table_tests[-c(1,7,13,19,25),] %>% as.data.frame()
colnames(df) <- c("EGARCH", "GJRGARCH", "TGARCH", "NAGARCH", "AVGARCH")
df <- as.matrix(df)
rownames(df) <- c("AE VaR","AE CVaR", "UC","CC","DQ","AE VaR","AE CVaR","UC","CC","DQ","AE CVaR","AE CVaR","UC","CC","DQ","AE VaR","AE CVaR","UC","CC","DQ","AE VaR","AE CVaR","UC","CC","DQ")
# writexl::write_xlsx(df, "findings/table4.xlsx")
```

```{r importtable4, eval=F}
df <- read_xlsx("findings/table4.xlsx")
```

With the SGED as underlying distribution, the ratio of actual to expected VaR exceedances is highest for the GJRGARCH model, with an excess exceedance rate of 24%. The other GARCH models still have a positive but slightly lower excess exceedance rate of 21%. The ratio of actual to expected CVaR exceedances gives a similar picture, with the highest excess exceedance rate being the GJRGARCH with 25% and for the other models 21%. These results are significant at the 5% level, except for the NAGARCH, which is significant only at the 10% level. This points that the difference between actual and expected exceedances is significantly different from 0. For all models under the SGED, the unconditional and conditional cover test and the dynamic quantile test statistics are insignificant. This suggests that the SGED is a good distribution for calculating VaR and CVaR.

With the ST as underlying distribution, the ratio of actual to expected VaR exceedances is highest for the TGARCH model, with an excess exceedance rate of 28%. The NAGARCH model has the lowest VaR excess exceedance rate of 17%. For the CVaR excess exceedance rate, there is a similar picture, with the TGARCH having an excess exceedance rate of 29% and the NAGARCH of 18%. These results are insignificant, thus it cannot be concluded that the excess exceedance for VaR and CVaR are significantly different from 0. Both the unconditional and conditional cover tests are insignificant. However, the dynamic quantile test is significant at the 10% level for the EGARCH and TGARCH. This suggests that the ST distribution is a good distribution for calculating VaR and CVaR, though not as good as the SGED.

The GED, T and normal distribution have significant unconditional and conditional and dynamic quantile test statistics for most models, which suggest they are less appropriate for modeling VaR and CVaR.

\newpage

```{r table4, echo=F, results='asis'}
df %>% kbl(booktabs=T,
           caption = "VaR and CVaR test statistics",
      label = 'Table4',row.names = T) %>%
  kable_styling() %>%
  kable_classic(full_width = F)%>%
  pack_rows("Panel A: SGED", 1,5) %>%
  pack_rows("Panel B: GED", 6,10) %>%
  pack_rows("Panel C: ST", 11,15) %>%
  pack_rows("Panel D: T", 16,20) %>%
  pack_rows("Panel E: N", 21,25) %>% add_indent(c(1:17, 18:25)) %>%
  footnote(general = "Table contains the ratio of actual to expected exceedances for VaR and Conditional VaR, the unconditional and conditional coverage test statistic and the dynamic quantile test statistic for VaR. Significance levels for the VaR ratio not reported. *, ** and *** point out significance at 10, 5 and 1 percent level.",threeparttable = T,footnote_as_chunk = F, escape=F, general_title = "Notes:") 
```

\clearpage

## Time-varying higher moments

As we already pointed out in part \@ref(lit-rev), it might also be interesting to look at time-varying moments and check if there is an improvement for estimating the VaR and CVaR as @bali2008 did for example.

```{r acdcode, eval = FALSE}
# ACD specification
spec = racd::acdspec(mean.model = list(armaOrder = c(1, 0)), variance.model = list(variance.targeting = TRUE),distribution.model = list(model = 'sstd', skewOrder = c(1, 1, 1), shapeOrder = c(1,1,1), skewmodel = 'pwl', shapemodel = 'pwl'))

# sGARCH, takes 2.5 minutes
fit = racd::acdfit(spec, R, solver = 'msoptim', solver.control = list(restarts = 10)) #starts from different starting values to find an optimum
```

```{r avoidacdcode, echo=F}
# save.image("envplusacd.RData")
```

<!--# Filippo can you maybe make the table like you did with table.3? it's similar but we don't need a list. -->

```{r Table5prep, echo=F}
object <- fit@fit$robust.matcoef
rownames(object) <- revalue(rownames(object),c("mu"="$\\alpha_0$", "ar1"="$\\alpha_1$", "omega"= "$\\beta_0$", "alpha1"="$\\beta_1$", "beta1"="$\\beta_2$", "skcons"="$\\chi_0$", "skalpha1"="$\\chi_1$", "skgamma1"="$\\chi_2$", "skbeta1"="$\\xi_1$", "shcons" = "$\\kappa_{0}$","shalpha1"="$\\kappa_{1}$","shgamma1"= "$\\kappa_{2}$",  "shbeta1"="$\\psi_{1}$"))
object <- round(object[,-3],3)

object[which(object[,3]>=0.10),2] <- paste0("(",object[which(object[,3]>=0.10),2],")")
object[which(object[,3]<0.10&object[,3]>0.05),2] <- paste0("(",object[which(object[,3]<0.10&object[,3]>0.05),2],")*")
object[which(object[,3]<=0.05&object[,3]>0.01),2] <- paste0("(",object[which(object[,3]<=0.05&object[,3]>0.01),2],")**")
object[which(object[,3]<=0.01),2] <- paste0("(",object[which(object[,3]<=0.01),2],")***")
object.df <- as.data.frame(object[,-3])
object.df[is.na(object.df)] <- ""
colnames(object.df) <- c("ACD GARCH" , "")

object.df <- rbind(object.df[c(1,2),],object.df[rownames(object.df)=="$\\beta_0$",],object.df[-c(1,2,rownames(object.df)=="$\\beta_0$"),])[-nrow(rbind(object.df[c(1,2),],object.df[rownames(object.df)=="$\\beta_0$",],object.df[-c(1,2,rownames(object.df)=="$\\beta_0$"),])),]
```


```{r Table5, echo=F, results='asis'}
#require(magrittr)
fn1.3c <- sprintf(paste0('This table shows the maximum likelihood estimates of the ST-ACD model. The daily returns used on the ',stringr::str_to_title(gsub(pattern = '\\.', replacement=' ',colnames(R)))," Price index cover the period from ",gsub(" UTC", "",format(min(index(R)), '%d %B, %Y'))," to ",gsub(" UTC", "",format(max(index(R)),'%d %B, %Y')), " (", nrow(R)," observations)."))
fn2.3 <- "The mean process is modeled as follows: $R_t= \\\\alpha_0+ \\\\alpha_1 \\\\times R_{t-1}+ \\\\varepsilon_t$ Where, in the model estimated, $\\\\gamma$ is the asymmetry in volatility,  (calculated using robust standard errors based on the method of White (1982)) are displayed in parenthesis."

table5 <- data.frame(paste(object.df[,1]," ", object.df[,2]))
colnames(table5) <- "ACD-GARCH"
rownames(table5) <- rownames(object.df) 
table5 %>% kbl(col.names = toupper(colnames(object.df)[1]),caption = "Maximum likelihood estimates of the ST-ACD model with constant skewness and kurtosis parameters",#format = "latex",
      label = 'Table5',
      booktabs = TRUE, row.names = T, escape = F, longtable=T) %>%
  kable_classic(full_width = T) %>%
  footnote(general = c(fn1.3b,fn2.3),threeparttable = T,footnote_as_chunk = F, escape=F, general_title = "Notes:")
```

The following figure \@ref(fig:figureACDmoments) plots the conditional mean, the conditional volatility. The implied conditional time varying skewness and excess kurtosis for the Euro Stoxx 50 series.

```{r figureACDmoments, fig.cap = "Dynamics of the ACD model", fig.align='center',fig.pos='h', echo=FALSE}
require(racd)
par(mfrow = c(2, 2), mai = c(0.4, 0.75, 0.2, 0.3))
plot.zoo(fit@fit$fitted.values,main = 'Conditional Mean', col = 'steelblue',xlab = "Time", ylab = "")
plot(as.zoo(abs(R)), main = 'Conditional Sigma',col = c('grey'),xlab = "Time", ylab = "");lines(as.zoo(rugarch::sigma(fit)),col= 'steelblue'); legend(x="topleft", legend = c("absolute log-returns", "conditional volatility"), col = c('grey', 'steelblue'),lty = c(1,1), bty = 'n', cex = 0.8)

plot(as.zoo(racd::skewness(fit)), col = 'steelblue', ylab = "", main = 'Conditional Skewness',xlab = "Time")
plot(as.zoo(racd::kurtosis(fit)), col = 'steelblue', ylab = "", main = 'Conditional Excess Kurtosis',xlab = "Time")
```

\newpage

\noindent After performing a backtest[^findings-2], we observe that the ACD model is slightly worse than the GARCH equivalent in estimating the VaR. Although there are much less models tested here because of the difficulty of the procedure of ACD models, we find less convincing evidence of the merit of using conditional higher moments in VaR and CVaR estimation. So contrary to @bali2008, we find that the ACD models seem to underperform to the GARCH model. With a rejection of unconditional coverage test statistic at 10% significance level. It is not surprising that the GARCH model performs bad as well looking at the rejection of the dynamic quantile test and the CVaR test.

[^findings-2]: This backtest contains the following features: recursive, window of 2500, refitted every 250 trading days (approximately one year).

```{r acdbacktest, eval=FALSE}
spec = racd::acdspec(mean.model = list(armaOrder = c(1, 0)), variance.model = list(variance.targeting = TRUE),distribution.model = list(model = 'sstd', skewOrder = c(1, 1, 1), shapeOrder = c(1,1,1), skewmodel = 'pwl', shapemodel = 'pwl'))

# Backtest ----
rollacd = racd::acdroll(spec, R, n.start = 2500, refit.every = 250, refit.window = 'recursive', calculate.VaR = TRUE, VaR.alpha = 0.01)
# Benchmark ----
gspec = ugarchspec(mean.model = list(armaOrder = c(1, 0)), variance.model = list(variance.targeting = TRUE), distribution = 'sstd')
rollg = ugarchroll(gspec, R, n.start = 2500, refit.every = 250, refit.window = 'recursive')
```

```{r acdbacktestresults, echo=FALSE}
# Table
# VaRTest----
vartable = rbind(
  as.data.frame(
    VaRTest(alpha = 0.01, 
          actual =rollacd@forecast$VaR[,'realized'], 
          VaR = rollacd@forecast$VaR[, 'alpha(1%)']), 
  row.names =c('ACD(1%)')),
  as.data.frame(
    VaRTest(alpha = 0.01, 
            actual = rollg@forecast$VaR[, 'realized'],
            VaR = rollg@forecast$VaR[, 'alpha(1%)']), 
    row.names = c('GARCH(1%)')))

vartable2 <- vartable %>% mutate(AE = actual.exceed/expected.exceed)
vartable2 <- vartable2 %>% select(AE, uc.LRstat, uc.LRp, cc.LRstat, cc.LRp)
vartable2 <- round(vartable2,3)

vartable2[1,2] <- paste0(vartable2[1,2],signific(vartable2[1,3]))
vartable2[2,2] <- paste0(vartable2[2,2],signific(vartable2[2,3]))

vartable2[1,4] <- paste0(vartable2[1,4],signific(vartable2[1,4]))
vartable2[2,4] <- paste0(vartable2[2,4],signific(vartable2[2,4]))

vartable2 <- vartable2 %>% select(AE,uc.LRstat, cc.LRstat)

# ESTest modified----

sacd_sstd_ES <- ESTestingACD(rollacd, var = as.vector(rollacd@forecast$VaR$`alpha(1%)`), "sstd")

sgarchnonacd_sstd_ES <- ESTesting(rollg, var = rollg@forecast$VaR$`alpha(1%)`, "sstd")

sacd_sstd_AE_ES <- sacd_sstd_ES[2]
sacd_sstd_AE_p <- sacd_sstd_ES[[3]] 
sacd_sstd_AE_ES <-paste0(round(sacd_sstd_AE_ES[[1]],3), signific(sacd_sstd_AE_p))

sgarchnonacd_sstd_AE_ES <- sgarchnonacd_sstd_ES[2]
sgarchnonacd_sstd_AE_p <- sgarchnonacd_sstd_ES[[3]] 
sgarchnonacd_sstd_AE_ES <-paste0(round(sgarchnonacd_sstd_AE_ES[[1]],3), signific(sgarchnonacd_sstd_AE_p))

# DQ Test
DQ_ACD <- BacktestVaR(R[2501:nrow(R)],rollacd@forecast$VaR$`alpha(1%)`,0.01, 5)$DQ
DQ_nonacd <- BacktestVaR(R[2501:nrow(R)],rollg@forecast$VaR$`alpha(1%)`,0.01, 5)$DQ

DQ_ACD_stat <- paste0(round(DQ_ACD$stat,3), signific(DQ_ACD$pvalue))
DQ_nonacd_stat <- paste0(round(DQ_nonacd$stat,3), signific(DQ_nonacd$pvalue))

table_tests_acd <- matrix(nrow=5,ncol=2)
rownames(table_tests_acd) <- c("AE VaR","AE CVaR", "UC","CC", "DQ")
colnames(table_tests_acd) <- c("ACD", "GARCH")

table_tests_acd[1,] <- vartable2[,1]
table_tests_acd[2,] <- c(sacd_sstd_AE_ES,sgarchnonacd_sstd_AE_ES)
table_tests_acd[3,] <- vartable2[,2]
table_tests_acd[4,] <- vartable2[,3]
table_tests_acd[5,] <- c(DQ_ACD_stat,DQ_nonacd_stat)
```

\newpage

```{r tableACDBacktest, echo = FALSE, results='asis'}
table_tests_acd %>% kbl(booktabs=T,format="latex",
           caption = "VaR and ES test statistics (ACD-ST vs GARCH-ST)",
      label = 'tableACDBacktest',row.names = T, longtable=T) %>%
  kable_styling() %>%
  kable_classic(full_width = T)%>%
  footnote(general = "Table contains the ratio of actual to expected exceedances for VaR and Expected Shortfall, the unconditional and conditional coverage test statistic and the dynamic quantile test statistic for VaR. Significance levels for the VaR ratio not reported. *, ** and *** point out significance at 10, 5 and 1 percent level.",threeparttable = T, footnote_as_chunk = F, escape=F, general_title = "Notes:")
```

# Robustness checks {#Robustness}

```{r tabletestsfunction, echo=FALSE, results='asis'}
#create a function to make Lj box test on absolute residuals(((Change the number 1 into how many days back you want to test)))

```

```{r lbtableprep, echo=FALSE, results='asis'}
#LJUNG-BOX TEST ON STANDARDIZED SQUARED RESIDUALS
#create a function to make Lj box test for squared residuals(((Change the number 22 into how many days back you want to test)))

LJ.test.df.2 <- Table.tests.function(Lj.box.test.function.2, return.matrix = F)
LJ.test.df.all <- LJ.test.df.2
LJ.test.df.all <- as.matrix(LJ.test.df.all)
```

\noindent In order to check if the models are specified correctly, some diagnostic checks have to be performed. The specification checks have to be done on the standardized residuals of the estimated GARCH model given by the following equation: $$ \hat{Z_t} = \dfrac{\hat{\varepsilon_t}}{\hat{\sigma_t}} = \dfrac{R_t - \hat{\mu}}{\hat{\sigma_t}}$$.

Table \@ref(tab:LjboxTable) Panel A displays the Ljung-box test on the squared standardized residuals of the GARCH models. Panel B displays the ARCH LM test on the squared standardized residuals. The ARCH LM test checks if the ARCH process is adequately fitted.

The description of table

```{r archlmtableprep, echo=FALSE}
#SIGNbias <- signbias(garchfit.sGARCH[[1]])
#Nyblom <- nyblom(garchfit.sGARCH[[1]])
#t.test(rugarch::residuals(garchfit.sGARCH[[1]], standardize = T), mu = 0)
#jarqueberaTest(rugarch::residuals(garchfit.eGARCH[[1]], standardize = T))
#lillieTest(rugarch::residuals(garchfit.eGARCH[[1]], standardize = T))
#WeightedPortTest::Weighted.LM.test(garchfit.eGARCH[[1]]@fit$residuals, garchfit.eGARCH[[1]]@fit$sigma, lag = 22) #Li Mak test

#ARCH lm TEST
ARCH.lm.Test.df <- Table.tests.function(archlmtest, return.matrix = T)

# ARCH.lm.Test.df %>% kbl(caption = "ARCH LM Test",
#       label = 'ARCHLMTable',
#       booktabs = T,
#       position = "h!",
#       digits = 3 )%>%
#   kable_classic(full_width = F)%>%
#   footnote(general = "Notes",number=c("This table shows the ARCH LM statistics value for the respective model", "DESCRIBE PVALUES ***, **, *"),threeparttable = T,footnote_as_chunk = F, escape=F, general_title = "") %>%
#   kable_styling(latex_options = "scale_down") %>% landscape()

# install.packages("FinTS")
# FinTS::ArchTest(rugarch::residuals(garchfit.eGARCH[[1]], standardize = T), lags = 22)
```

```{r heterosctable, results='asis'}
heterosc.all <- rbind(LJ.test.df.all, ARCH.lm.Test.df)
heterosc.all %>% kbl(caption = "Diagnostic Tests for Heteroscedasticity",
      label = 'LjboxTable',
      booktabs = T,
      position = "h!",
      digits = 3 )%>%
  kable_classic(full_width = F)%>%
  pack_rows("Panel A: Ljung Box Test on the standardized squared values of the residuals", 1,5) %>% 
  pack_rows("Panel B: ARCH LM Test on the standardized squared values of the residuals", 6,10) %>%
  footnote(general_title = "Notes",general=c(paste0("Table displays the Ljung box statistics and the ARCH LM Test for the standardized squared residuals of the models analyzed. The underlying data is the daily return series of the Euro Stoxx 50 for the period between ", format(min(index(R)))," and ",format(max(index(R))),"."), "*, ** and *** point out respectively significance at 10, 5 and 1 percent level.", "The null hypothesis of the test in both panels are described as follows:","$H_0$: $Corr$($Z_t^2$,$Z_{t-1}^2$)=$Corr$($Z_t^2$,$Z_{t-2}^2$)= $...$ =$Corr$($Z_t^2$,$Z_{t-22}^2$) = $0$"),threeparttable = T,footnote_as_chunk = F, escape=F) %>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

```{r gmmtestprep, echo=F}
#GMM test



GMM.mean <- GMM.table.function(function.to.apply = GMMTest.2, return.matrix = T, col.numb = 1)
GMM.var <- GMM.table.function(function.to.apply = GMMTest.2, return.matrix = T, col.numb = 2)
GMM.skew <- GMM.table.function(function.to.apply = GMMTest.2, return.matrix = T, col.numb = 3)
GMM.kurt <- GMM.table.function(function.to.apply = GMMTest.2, return.matrix = T, col.numb = 4)

GMM.norm <- rbind(GMM.mean[1,],GMM.var[1,],GMM.skew[1,],GMM.kurt[1,])
GMM.t <- rbind(GMM.mean[2,],GMM.var[2,],GMM.skew[2,],GMM.kurt[2,])
GMM.st <- rbind(GMM.mean[3,],GMM.var[3,],GMM.skew[3,],GMM.kurt[3,])
GMM.ged <- rbind(GMM.mean[4,],GMM.var[4,],GMM.skew[4,],GMM.kurt[4,])
GMM.sged <- rbind(GMM.mean[5,],GMM.var[5,],GMM.skew[5,],GMM.kurt[5,])

rownames(GMM.norm) <- rownames(GMM.t) <- rownames(GMM.st) <- rownames(GMM.ged) <- rownames(GMM.sged) <- c("Mean", "Variance", "Skewness", "Excess Kurtosis")
GMM.all <- rbind(GMM.sged,GMM.ged,GMM.st,GMM.t,GMM.norm)
```

The Generalized Method of Moments (GMM) test by @hansen1982 is also a test that checks if the model is correctly specified or not. Here only the results of the t-tests for the four individual moments are examined from the GMM test[^findings-3]. The mean (first moment) should be equal to zero (or or $E\left[z_{t}\right]=0$). The variance (second moment) should be equal to one (or $E\left[z_{t}^2-1\right]=0$). The skewness should be equal to zero and the excess kurtosis (third and fourth moment) should be equal to zero ( respectively $E\left[z_{t}^3\right]=0$ and $E\left[z_{t}^4-3\right] = 0$).

[^findings-3]: We already looked at the joint conditional moment: serial correlation in the squares or in the variances

```{r gmmtable, echo=F}
GMM.all %>% kbl(caption = "GMM Tests",format = "latex",
      label = 'GMMtable',
      booktabs = T,
      position = "h!",
      digits = 3 )%>%
  kable_classic(full_width = F)%>%
  pack_rows("Panel A: SGED", 1,4) %>%
  pack_rows("Panel B: GED", 5,8) %>%
  pack_rows("Panel C: ST", 9,12) %>%
  pack_rows("Panel D: T", 13,16) %>%
  pack_rows("Panel E: N", 17,20) %>%
  footnote(general_title = "Notes",general=c(paste0("Table displays the GMM test statistics for the standardized residuals. The underlying data is the daily return series of the Euro Stoxx 50 for the period between ", format(min(index(R)))," and ",format(max(index(R))),"."), "The null hypothesis of the test for each variable are described as follows: $H_0: $ $E[z_{t}] = 0$ for the mean, $H_0: $ $E[z_{t}^2-1] = 0$ for the variance. $H_0: $ $E[z_{t}^3] = 0$ for the skewness and $H_0: $ $E[z_{t}^4-3] = 0$ for the excess kurtosis."),threeparttable = T,footnote_as_chunk = T, escape=F) %>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

```{r JBtable, echo=F, results="asis"}
#create a function to make JB test for residuals(((Change the number 22 into how many days back you want to test)))

JB.test.df <- suppressWarnings(Table.tests.function(Jarque.bera.test.function, return.matrix = T))
 JB.test.df %>% kbl(caption = "Jarque-Bera Test on standardized residuals",format="latex",
      label = 'JBTable',
      booktabs = T,
      position = "h!",
      digits = 3 )%>%
  kable_classic(full_width = F)%>%
  footnote(general_title = "Notes",general=c(paste0("Table displays the Jarque-Bera statistic $JB=\\\\frac{n}{6}(S^{2}+\\\\frac{1}{4}(K-3)^{2})$ with $n$ the sample size, $K$ the kurtosis and $S$ the skewness for the residuals of the models. The JB statistic is distributed $\\\\chi^2$ with $\\\\nu = 2$. The underlying data is the daily return series of the Euro Stoxx 50 for the period between ", format(min(index(R)))," and ",format(max(index(R))),"."), "*, ** and *** point out respectively significance at 10, 5 and 1 percent level.", "The null hypothesis is that $S$ and $K$ are not significantly different than what would be found under normality (0 and 3)."),threeparttable = T,footnote_as_chunk = T, escape=F) %>%
  kable_styling(latex_options = "scale_down") %>% landscape()
```

[^findings-4]

[^findings-4]: Note that using monthly returns instead of daily, it cannot be rejected that the residuals are normally distributed.

<!-- #WeightedPortTest::Weighted.LM.test(rugarch::residuals(garchfit.eGARCH[[1]]), sigma(garchfit.eGARCH[[1]]), lag = 22) -->

<!-- ``` -->

DESCRIPTION GRAPHS

```{r figuresqq, fig.cap="QQ plots of AVGARCH residuals versus the standardized returns of the series",fig.align='center', out.width="100%",fig.pos="h",echo=F}
par(mfrow = c(1,2), mar = c(5.1, 4.1, 2.1, 2.1))
qqnorm(rugarch::residuals(garchfit.fGARCH.AVGARCH[[4]], standardize = T), main = "AVGARCH Residuals")
qqline(rugarch::residuals(garchfit.fGARCH.AVGARCH[[4]], standardize = T))
qqnorm(scale(R), main = "Raw standardized returns")
qqline(scale(R))

# plot(density(rugarch::residuals(garchfit.fGARCH.AVGARCH[[4]], standardize = T)), lwd = 2, main = "AV GARCH Residuals")
# curve(dnorm(x, mean=mean(rugarch::residuals(garchfit.fGARCH.AVGARCH[[4]], standardize = T)), sd=sd(rugarch::residuals(garchfit.fGARCH.AVGARCH[[4]], standardize = T))), 
#       col="cornflowerblue", lwd=2, add=TRUE, yaxt="n")
# plot(density(scale(R)), lwd = 2, main = "Raw standardized returns")
# curve(dnorm(x, mean=0, sd=sd(scale(R))), 
#       col="cornflowerblue", lwd=2, add=TRUE, yaxt="n")

```
