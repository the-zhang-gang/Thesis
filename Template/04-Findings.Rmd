---
output:
  bookdown::pdf_document2:
    template: templates/brief_template.tex
    citation_package: biblatex
  #bookdown::word_document2: default
  #bookdown::html_document2: default
documentclass: book
bibliography: references.bib
---

# Empirical Findings {#analysis}

\minitoc <!-- this will include a mini table of contents-->

```{r include=F}
require(readxl)
require(xts)
require(PerformanceAnalytics)
require(kableExtra)
require(rugarch)
require(fitdistrplus)
require(fGarch) 
require(tree)  # do we need this?
require(sgt)
require(devtools)
remotes::install_github("R-Finance/xtsExtra")
install_bitbucket("alexiosg/racd")
data <- read_excel("data/datastream.xlsx",col_types = c("date", rep("numeric", 6)),skip = 2) #warnings are NA's
colnames(data) <- c("Date",gsub(pattern = " - PRICE INDEX", replacement='' , colnames(data)[2:7]))
Price_indices <- as.xts(data[,-1], order.by = data$Date)
Estoxx <- Price_indices[,1] #see if price index
R <- diff(Estoxx, log = TRUE, na.pad = FALSE)*100
```
##MLE distribution parameters 


```{r SGT.MLE, echo=F}
sgt.mle2 <- function (X.f, mu.f = mu ~ mu, sigma.f = sigma ~ sigma, lambda.f = lambda ~ 
            lambda, p.f = p ~ p, q.f = q ~ q, data = parent.frame(), 
          start, subset, method = "BFGS", itnmax = NULL, 
          hessian.method = "Richardson", gradient.method = "Richardson", 
          mean.cent = TRUE, var.adj = TRUE, ..., lower =-Inf, upper=Inf) {
  formList = list(X = X.f, mu = mu.f, sigma = sigma.f, lambda = lambda.f, 
                  p = p.f, q = q.f)
  varNames = NULL
  envir = new.env()
  for (i in 1:6) {
    formList[[i]] = stats::as.formula(formList[[i]])
    if (length(formList[[i]]) == 2L) {
      formList[[i]][[3L]] = formList[[i]][[2L]]
      formList[[i]][[2L]] = as.name(names(formList)[i])
    }
    else if (as.character(formList[[i]][[2L]]) != names(formList)[i]) {
      warning(paste("The left hand side of ", names(formList)[i], 
                    ".f was changed from ", as.character(formList[[i]][[2L]]), 
                    " to ", names(formList)[i], sep = ""))
    }
    varNames = c(varNames, all.vars(formList[[i]][[3L]]))
  }
  if (class(data)[1L] == "matrix") 
    data = as.data.frame(data)
  if (!is.list(data) && !is.environment(data)) 
    stop("'data' must be a list or an environment")
  start = as.list(start)
  if (is.null(names(start))) 
    stop("'start' must be a named list or named numeric vector")
  if ("" %in% names(start)) 
    stop("at least one of the elements in 'start' is missing a name")
  parNames = names(start)
  varNames = varNames[is.na(match(varNames, parNames))]
  if (length(varNames) == 0L) 
    stop("there is no reference to data in the given formulas")
  for (i in varNames) {
    if (!exists(i, data)) 
      stop(paste(i, "is not contained in 'start' and it is not found in 'data'"))
    assign(i, eval(parse(text = paste("as.numeric(data$", 
                                      i, ")", sep = ""))), envir)
  }
  if (length(varNames) > 1) {
    for (i in 2:length(varNames)) {
      if (length(eval(parse(text = paste("envir$", varNames[1L], 
                                         sep = "")))) != length(eval(parse(text = paste("envir$", 
                                                                                        varNames[i], sep = ""))))) 
        stop(paste("the length of the variable", varNames[i], 
                   "does not match the length of the variable", 
                   varNames[1L]))
    }
  }
  control = list(...)
  if (!is.null(control$maximize)) 
    stop("'maximize' option not allowed")
  if (!missing(subset)) 
    for (i in varNames) assign(i, eval(parse(text = paste("envir$", 
                                                          i, "[subset]", sep = ""))), envir)
  keep = rep(TRUE, length(eval(parse(text = paste("envir$", 
                                                  varNames[1L], sep = "")))))
  for (i in varNames) keep = keep & is.finite(eval(parse(text = paste("envir$", 
                                                                      i, sep = ""))))
  for (i in varNames) assign(i, eval(parse(text = paste("envir$", 
                                                        i, "[keep]", sep = ""))), envir)
  loglik = function(params) {
    for (i in 1:length(parNames)) assign(parNames[i], unlist(params[i]))
    X = eval(formList[[1L]][[3L]])
    mu = eval(formList[[2L]][[3L]])
    sigma = eval(formList[[3L]][[3L]])
    lambda = eval(formList[[4L]][[3L]])
    p = eval(formList[[5L]][[3L]])
    q = eval(formList[[6L]][[3L]])
    sum(dsgt(X, mu, sigma, lambda, p, q, mean.cent, var.adj, 
             log = TRUE))
  }
  environment(loglik) = envir
  negloglik = function(params) {
    -loglik(params)
  }
  if (!is.finite(loglik(start))) 
    stop("'start' yields infinite or non-computable SGT function values")
  optimum = suppressWarnings(optimx::optimx(par = unlist(start), 
                                            fn = negloglik, method = method, itnmax = itnmax, control = control, lower=lower, upper=upper))
  minimum = min(optimum$value, na.rm = TRUE)
  if (!is.finite(minimum)) 
    stop("All Maximization Methods Failed")
  whichbest = max(which(minimum == optimum$value))
  optimal = optimum[whichbest, ]
  estimate = as.numeric(optimum[whichbest, 1:length(parNames)])
  names(estimate) = parNames
  H = tryCatch(numDeriv::hessian(loglik, estimate, method = hessian.method), 
               error = function(e) {
                 warning("hessian matrix calculation failed")
                 return(as.matrix(NaN))
               })
  varcov = tryCatch(-qr.solve(H), error = function(e) {
    warning("covariance matrix calculation failed due to a problem with the hessian")
    return(as.matrix(NaN))
  })
  std.error = sqrt(diag(varcov))
  if (is.finite(varcov[1, 1])) 
    names(std.error) = parNames
  gradient = tryCatch(numDeriv::grad(loglik, estimate, method = gradient.method), 
                      error = function(e) {
                        warning("gradient calculation failed")
                        return(NaN)
                      })
  result = list(maximum = -minimum, estimate = estimate, convcode = as.numeric(optimal$convcode), 
                niter = as.numeric(optimal$niter), best.method.used = row.names(optimal), 
                optimx = optimum, hessian = H, gradient = gradient, 
                varcov = varcov, std.error = std.error)
  class(result) = c("sgtest", class(result))
  return(result)
}
```

```{r mlesgt, echo=F}
library(sgt)
require(graphics)
require(stats)


DistMLE <- function(series) {
  
  ### SGT
  X.data <- X ~ coredata(series)
  
  SGT_start <- list(mu = 0, sigma = 2, lambda = 0, p = 2, q = 12)
  SGT_result <- sgt.mle2(X.f = X.data, start = SGT_start)
  SGT_sumResult <- summary(SGT_result)
  SGT_AIC <- 2*length(SGT_result$estimate) - 2*SGT_sumResult$maximum
  
  ### SGT plot fit
  xvals = seq(-3,3,by=0.01)
  SGT_mu <- SGT_result$estimate[1]
  SGT_sigma <- SGT_result$estimate[2]
  SGT_lambda <- SGT_result$estimate[3]
  SGT_p <- SGT_result$estimate[4]
  SGT_q <- SGT_result$estimate[5]
  plot(xvals, dsgt(xvals, mu = SGT_mu, sigma = SGT_sigma, lambda = SGT_lambda, p = SGT_p, q = SGT_q), col="red", type ="l",main = "SGT (sgt.mle2)")
  lines(density(coredata(series)))
  
  
  
  ### SGED (sgt.mle2)
  
  SGED_start <- list(mu = 0, sigma = 2, lambda = 0, p = 2, q = 750)
  SGED_result <- sgt.mle2(X.f = X.data, start = SGED_start, lower = c(-Inf, -Inf, -Inf, -Inf,749.9), upper = c(Inf,Inf,Inf,Inf,750.1))
  SGED_sumResult <- summary(SGED_result)
  SGED_AIC <- 2*length(SGED_result$estimate-1) - 2*SGED_sumResult$maximum
  
  ### SGED Plot fit (sgt.mle2)
  SGED_mu <- SGED_result$estimate[1]
  SGED_sigma <- SGED_result$estimate[2]
  SGED_lambda <- SGED_result$estimate[3]
  SGED_p <- SGED_result$estimate[4]
  SGED_q <- SGED_result$estimate[5]
  plot(xvals, dsgt(xvals, mu = SGED_mu, sigma = SGED_sigma, lambda = SGED_lambda, p = SGED_p, q = SGED_q), col="red", type ="l", main = "SGED (sgt.mle2)")
  lines(density(coredata(series)))
  
  ### GT(sgt.mle2)
  GT_start <- list(mu = 0, sigma = 2, lambda = 0, p = 2, q = 12)
  GT_result <- sgt.mle2(X.f = X.data, start = GT_start, lower = c(-Inf, -Inf, -0.001, -Inf,-Inf), upper = c(Inf,Inf,0.001,Inf,Inf))
  GT_sumResult <- summary(GT_result)
  GT_AIC <- 2*length(GT_result$estimate-1) - 2*GT_sumResult$maximum
  
  ### GT Plot fit (sgt.mle2)
  GT_mu <- GT_result$estimate[1]
  GT_sigma <- GT_result$estimate[2]
  GT_lambda <- GT_result$estimate[3]
  GT_p <- GT_result$estimate[4]
  GT_q <- GT_result$estimate[5]
  plot(xvals, dsgt(xvals, mu = GT_mu, sigma = GT_sigma, lambda = GT_lambda, p = GT_p, q = GT_q), col="red", type ="l", main = "GT (sgt.mle2)")
  lines(density(coredata(series)))
  
  
  
  
  ### GED(sgt.mle2)
  GED_start <- list(mu = 0, sigma = 2, lambda = 0, p = 2, q = 750)
  GED_result <- sgt.mle2(X.f = X.data, start = GED_start, lower = c(-Inf, -Inf, -0.000001, -Inf,749.9), upper = c(Inf,Inf,0.000001,Inf,750.1))
  GED_sumResult <- summary(GED_result)
  GED_AIC <- 2*length(GED_result$estimate-2) - 2*GED_sumResult$maximum
  
  ### GED Plot fit (sgt.mle2)
  
  GED_mu <- GED_result$estimate[1]
  GED_sigma <- GED_result$estimate[2]
  GED_lambda <- GED_result$estimate[3]
  GED_p <- GED_result$estimate[4]
  GED_q <- GED_result$estimate[5]
  plot(xvals, dsgt(xvals, mu = GED_mu, sigma = GED_sigma, lambda = GED_lambda, p = GED_p, q = GED_q), col="red", type ="l", main = "GED (sgt.mle2)")
  lines(density(coredata(series)))
  
  ### ST (fitdist) 
  ST_start <- list(mean=0,sd=2, nu = 8, xi=2)
  ST_result <- fitdistrplus::fitdist(data = as.vector(coredata(R)), distr = "sstd", method = "mle", ST_start)
  ST_sumResult <- summary(ST_result)
  ST_sumResult$aic
  
  ### ST Plot fit (fitdist)
  ST_mean <- ST_result$estimate[1]
  ST_sd <- ST_result$estimate[2]
  ST_nu <- ST_result$estimate[3]
  ST_xi <- ST_result$estimate[4] #lamda
  
  plot(xvals, dsstd(xvals, mean = ST_mean, sd = ST_sd, nu = ST_nu, xi=ST_xi), col="red", type ="l", main = "ST (fitdist)")
  lines(density(coredata(series)))
  
  ### T (fitdist) 
  T_start <- list(mean = 0, sd = 1, nu = 5)
  T_result <- fitdistrplus::fitdist(data = as.vector(coredata(R)), distr = "std", method = "mle", T_start)
  T_sumResult <- summary(T_result)
  
  ### T Plot fit (fitdist)
  T_mean <- T_result$estimate[1]
  T_sd <- T_result$estimate[2]
  T_nu <- T_result$estimate[3]
  
  
  plot(xvals, dstd(xvals, mean = T_mean, sd = T_sd, nu = T_nu), col="red", type ="l", main = "T (fitdist)")
  lines(density(coredata(series)))
  
  
  ### Normal (sgt.mle2)
  Normal_start <- list(mu = 0, sigma = 2, lambda = 0, p = 2, q = 950)
  Normal_result <- sgt.mle2(X.f = X.data, start = Normal_start, lower = c(-Inf, -Inf, -0.00000001, 1.999999999,949.9), upper = c(Inf,Inf,0.00000001,2.000000001,950.1))
  Normal_sumResult <- summary(Normal_result)
  Normal_AIC <- 2*length(Normal_result$estimate-3) - 2*Normal_sumResult$maximum
  
  ### Normal  Plot fit (sgt.mle2)
  
  Normal_mu <- Normal_result$estimate[1]
  Normal_sigma <- Normal_result$estimate[2]
  Normal_lambda <- Normal_result$estimate[3]
  Normal_p <- Normal_result$estimate[4]
  Normal_q <- Normal_result$estimate[5]
  
  if(!is.na(Normal_mu)){
  plot(xvals, dsgt(xvals, mu = Normal_mu, sigma = Normal_sigma, lambda = Normal_lambda, p = Normal_p, q = Normal_q), col="red", type ="l", main = "Normal (sgt.mle2)")
 lines(density(coredata(series)))}




#maximum likelihood estimates of unconditional distribution functions

Table2 <- matrix(nrow = 7, ncol = 8)
colnames(Table2) <- c("mu","sigma","lambda","p","q","nu","L","AIC")
rownames(Table2) <- c("SGT","SGED","GT","GED","ST","T","Normal")

Table2[1,1] <- SGT_mu
Table2[1,2] <- SGT_sigma
Table2[1,3] <- SGT_lambda
Table2[1,4] <- SGT_p
Table2[1,5] <- SGT_q
Table2[1,7] <- SGT_result$maximum
Table2[1,8] <- SGT_AIC

Table2[2,1] <- SGED_mu
Table2[2,2] <- SGED_sigma
Table2[2,3] <- SGED_lambda
Table2[2,4] <- SGED_p
Table2[2,5] <- SGED_q
Table2[2,7] <- SGED_result$maximum
Table2[2,8] <- SGT_AIC

Table2[3,1] <- GT_mu
Table2[3,2] <- GT_sigma
Table2[3,3] <- GT_lambda
Table2[3,4] <- GT_p
Table2[3,5] <- GT_q
Table2[3,7] <- GT_result$maximum
Table2[3,8] <- GT_AIC


Table2[4,1] <- GED_mu
Table2[4,2] <- GED_sigma
Table2[4,3] <- GED_lambda
Table2[4,4] <- GED_p
Table2[4,5] <- GED_q
Table2[4,7] <- GED_result$maximum
Table2[4,8] <- GED_AIC

Table2[5,1] <- ST_mean
Table2[5,2] <- ST_sd
Table2[5,3] <- ST_xi
Table2[5,6] <- ST_nu
Table2[5,7] <- ST_result$loglik
Table2[5,8] <- ST_result$aic

Table2[6,1] <- T_mean
Table2[6,2] <- T_sd
Table2[6,6] <- T_nu
Table2[6,7] <- T_result$loglik
Table2[6,8] <- T_result$aic

if(!is.na(Normal_mu)){
Table2[7,1] <- Normal_mu
Table2[7,2] <- Normal_sigma
Table2[7,3] <- Normal_lambda
Table2[7,4] <- Normal_p
Table2[7,5] <- Normal_q
Table2[7,7] <- Normal_result$maximum
Table2[7,8] <- Normal_AIC
}

return(Table2)
}
```




```{r MLE tables for different series}

MLE_Eurostoxx <- DistMLE(R)
MLE_Bali <- DistMLE(Rbali)


```

## Results of GARCH with constant higher moments

<!--# Here comes our main part [FILIPPO] -> to do!  -->

```{r garchcode, echo=F}
distributions <- c("norm", "std", "sstd", "sged", "ged")
#garchspec <- garchfit <- garchforecast <- stdret <- vector(mode = "list", length = length(distributions))
#names(garchspec) <- names(garchfit) <- names(garchforecast) <- names(stdret) <- distributions
Models.garch <- c("sGARCH", "eGARCH","fGARCH.AVGARCH","fGARCH.NAGARCH", "gjrGARCH", "apARCH", "iGARCH", "csGARCH")

for(i in 1:length(Models.garch)){
assign(paste0("garchspec.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
assign(paste0("garchfit.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
assign(paste0("stdret.",Models.garch[i]),vector(mode = "list", length = length(distributions)))
} 

# ls(pattern = "garchspec.")
# sapply(ls(pattern = "garchspec."), FUN = setNames, distributions)

#.sGARCH--------------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.sGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "sGARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.sGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.sGARCH[[i]])
# Compute stdret using residuals()
stdret.sGARCH[[i]] <- residuals(garchfit.sGARCH[[i]], standardize = TRUE)
}

#.eGARCH-------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.eGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "eGARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.eGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.eGARCH[[i]])
# Compute stdret using residuals()
stdret.eGARCH[[i]] <- residuals(garchfit.eGARCH[[i]], standardize = TRUE)
}

#.fGARCH.NAGARCH------------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.fGARCH.NAGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "fGARCH", submodel = "NAGARCH", variance.targeting = F),
                     distribution.model = distributions[i])
# Estimate the model
garchfit.fGARCH.NAGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.fGARCH.NAGARCH[[i]])
# Compute stdret using residuals()
stdret.fGARCH.NAGARCH[[i]] <- residuals(garchfit.fGARCH.NAGARCH[[i]], standardize = TRUE)
}

#.fGARCH.AVGARCH------------------------

for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.fGARCH.AVGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "fGARCH", submodel = "AVGARCH", variance.targeting = F),
                     distribution.model = distributions[i])
# Estimate the model
garchfit.fGARCH.AVGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.fGARCH.AVGARCH[[i]])
# Compute stdret using residuals()
stdret.fGARCH.AVGARCH[[i]] <- residuals(garchfit.fGARCH.AVGARCH[[i]], standardize = TRUE)
}

#.gjrGARCH------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.gjrGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "gjrGARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.gjrGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.gjrGARCH[[i]])
# Compute stdret using residuals()
stdret.gjrGARCH[[i]] <- residuals(garchfit.gjrGARCH[[i]], standardize = TRUE)
}

#.apARCH-------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.apARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "apARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.apARCH[[i]] <- ugarchfit(data = R, spec = garchspec.apARCH[[i]])
# Compute stdret using residuals()
stdret.apARCH[[i]] <- residuals(garchfit.apARCH[[i]], standardize = TRUE)
}

#.iGARCH--------------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.iGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "iGARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.iGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.iGARCH[[i]])
# Compute stdret using residuals()
stdret.iGARCH[[i]] <- residuals(garchfit.iGARCH[[i]], standardize = TRUE)
}

#.csGARCH-----------------
for(i in 1:length(distributions)){
# Specify a GARCH model with constant mean
garchspec.csGARCH[[i]] <- ugarchspec(mean.model = list(armaOrder = c(1,0)),
                     variance.model = list(model = "csGARCH", variance.targeting = F), 
                     distribution.model = distributions[i])
# Estimate the model
garchfit.csGARCH[[i]] <- ugarchfit(data = R, spec = garchspec.csGARCH[[i]])
# Compute stdret using residuals()
stdret.csGARCH[[i]] <- residuals(garchfit.csGARCH[[i]], standardize = TRUE)
}

#  make the histogram
# 
# chart.Histogram(stdret.iGARCH[[1]], methods = c("add.normal","add.density" ),
#                 colorset = c("gray","red","blue"))
```

## Results of GARCH with time-varying higher moments

```{r acdcode, include=F}
require(racd)
require(rugarch)
require(parallel)
require(xts)
# ACD specification
sGARCH_ACDspec = acdspec(mean.model = list(armaOrder = c(1, 0)), variance.model = list(variance.targeting = TRUE),
distribution.model = list(model = 'jsu', skewOrder = c(1, 1, 1), shapeOrder = c(1,1,1), skewmodel = 'quad', shapemodel = 'pwl'))

# sGARCH
cl = makePSOCKcluster(10)
fit = acdfit(sGARCH_ACDspec, as.data.frame(R), solver = 'msoptim', solver.control = list(restarts = 10),cluster = cl) #very long process: starts from different starting values to find an optimum
```

```{r figureACDmoments, fig.cap = "Dynamics of the ACD model", fig.align='center', fig.subcap="This figure plots the conditional mean, the conditional volatility. The implied conditional time varying skewwness and excess kurtosis for the Eurostoxx 50 series.", echo=F}
# plotxts comes from implementing https://stackoverflow.com/a/50051183/271616
par(mfrow = c(2, 2), mai = c(0.75, 0.75, 0.3, 0.3))
cm <- plot(xts(fit@model$modeldata$data, fit@model$modeldata$index), auto.grid = FALSE,minor.ticks = FALSE, main = 'Conditional Mean',yaxis.right = F, col = 'steelblue')
cm <- lines(fitted(fit), col = 2)
cm
cs <- plot(xts(abs(fit@model$modeldata$data),fit@model$modeldata$index), auto.grid = FALSE,
minor.ticks = FALSE, main = 'Conditional Sigma', yaxis.right = F,col = 'grey')
cs <- lines(sigma(fit), col = 'steelblue')
cs
plot(racd::skewness(fit), col = 'steelblue',yaxis.right = F, main = 'Conditional Skewness')
plot(racd::kurtosis(fit), col = 'steelblue', yaxis.right = F,main = 'Conditional Excess Kurtosis')

# pnl <- function(fitted(fit),xts(fit@model$modeldata$data, fit@model$modeldata$index), ...) {
#   panel.number <- parent.frame()$panel.number
# 	if (panel.number == 1) lines(fitted(fit), xts(fit@model$modeldata$data, fit@model$modeldata$index),col = "red")
# 	lines(fitted(fit),xts(fit@model$modeldata$data, fit@model$modeldata$index), col = "red")
# }
# plot(xts(fit@model$modeldata$data, fit@model$modeldata$index), auto.grid = T,minor.ticks = FALSE,major.ticks=T, yaxis.right = F, main = 'Conditional Mean', col = 'steelblue', xlab = "", screens = 1, ylab="") #panel = pnl
# # lines(fitted(fit), col = 2) + grid()
# 
# plot(xts(fit@model$modeldata$data, fit@model$modeldata$index), auto.grid = T,minor.ticks = FALSE,major.ticks=T, yaxis.right = F, main = 'Conditional Mean', col = 'steelblue', xlab = "", screens = 1, ylab="", )
```
